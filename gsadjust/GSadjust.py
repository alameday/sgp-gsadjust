#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
GSadjust, for the interactive network adjustment of relative-gravity networks
=============================================================================

Version 0.95
June 2019

Jeff Kennedy, USGS
jkennedy@usgs.gov

GSadjust is a Python 3.6/PyQt5 program that provides a graphical user interface for post-processing combined
relative- and absolute- gravity surveys.

GSadjust was originally based on PyGrav:
Hector, B. and Hinderer, J.: pyGrav, a Python-based program for handling and
processing relative gravity data, Computers & Geosciences, doi:10.1016/j.cageo.2016.03.010, 2016.

GSadjust is distributed with the network adjustment software Gravnet (Windows executable)
(Hwang, C., C. Wang and L. Lee. 2002. Adjustment of relative gravity measurements
using weighted and datum-free constraints. Computers & Geosciences 28 1005-1015)

This software is preliminary, provisional, and is subject to revision. It is being provided to meet the need for
timely best science. The software has not received final approval by the U.S. Geological Survey (USGS). No warranty,
expressed or implied, is made by the USGS or the U.S. Government as to the functionality of the software and related
material nor shall the fact of release constitute any such warranty. The software is provided on the condition that
neither the USGS nor the U.S. Government shall be held liable for any damages resulting from the authorized or
unauthorized use of the software.

GSadjust file organization is:

GSadjust.py:
  major PyQt elements (tabs, menus)
tab_data.py
  PyQt elements on the data tab
tab_drift.py
  PyQt elements on the drift tab
tab_network.py
  PyQt elements on the network adjustment tab
menus.py
  Creates PyQt menus
gui_objects.py:
  minor PyQt elements (popup windows/dialogs)
data_objects.py:
  Non Py-Qt data objects (Deltas, Datums, etc.)
  Network adjustment code
pyqt_models.py:
  PyQt-specific data models: ObsTreeSurvey, ObsTreeLoop, etc.
tide_correction.py:
  Earth tide and ocean loading code
synthetic_tides.py:
  Tide model coefficients
a10.py:
  Parses *.project.txt files generated by 'g' software (A-10 and FG-5 absolute-gravity meters)

PyQt models follow the PyQt CamelCase naming convention. The other methods/functions in GSadjust use PEP-8
lowercase_underscore convention.

The general data structure of the program is stored as PyQt objects inherited from QStandardItem:

+------------+
| Campaign   |
++-----------+
 |  +---------------------------+
 +--+ Surveys (ObsTreeSurvey)   |
    ++--------------------------+
     |  +-------------+
     +--+ Adjustment  |
     |  +-------------+
     |  +-------------+
     +--+ datum_model |
     |  +-------------+
     |  +-------------+
     +--+ delta_model |
     |  +-------------+
     |  +---------------+
     +--+ results_model |
     |  +---------------+
     |  +----------------------+
     |--+ Loops (ObsTreeLoop)  |
        ++---------------------+
         |  +--------------+
         +--+ delta_model  |
            ++-------------+
         |  +-------------+
         +--+ tare_model  |
            ++------------+
         |  +----------------------------+
         +--+ Stations (ObsTreeStation)  |
            ++---------------------------+
             |  +--------------------+
             +--+ g, lat, long, etc. |
                +--------------------+

The Adjustment object in each ObsTreeSurvey holds the network adjustment input, output, and options. There is one
Adjustment per Survey.

The datum_model, delta_model, results_model, and tare_model are PyQt models. The gui is update with the respective
model when a new Survey or Loop is selected (by double-clicking in the tree view). There is one of each table per
Survey.

"""

import copy
import logging
import os
# Standard library modules
import sys
import time
import traceback
import webbrowser

# For network graphs
# Modules that must be installed
import numpy as np
from PyQt5 import QtGui, QtCore, QtWidgets
from matplotlib.dates import num2date

from data_correction import time_correction
from data_export import export_metadata, export_summary, export_data
# GSadjust modules
from data_import import read_csv, read_burris, read_cg6, read_cg6tsoft, read_scintrex, import_abs_g_complete, \
    import_abs_g_simple
from data_objects import Datum, Tare, ChannelList, Delta, SimpleDelta
from gsa_plots import plot_loop_animation
from gsa_plots import plot_network_graph, plot_compare_datum_to_adjusted, plot_adjust_residual_histogram
from gui_objects import AddDatumFromList, CoordinatesTable
from gui_objects import FigureDatumComparisonTimeSeries
from gui_objects import GravityChangeTable, TideCorrectionDialog, TideCoordinatesDialog, ApplyTimeCorrection
from gui_objects import VerticalGradientDialog, AddTareDialog, MeterType, LoopTimeThresholdDialog, Overwrite
from menus import Menus, MENU_STATE
from pyqt_models import BurrisTableModel, ScintrexTableModel
from pyqt_models import ObsTreeModel, TareTableModel
from pyqt_models import ObsTreeStation, ObsTreeLoop, ObsTreeSurvey
from tab_data import TabData
from tab_drift import TabDrift
from tab_network import TabAdjust
from tide_correction import tide_correction_agnew, tide_correction_meter
from utils import *


class MainProg(QtWidgets.QMainWindow):
    """
    GSadjust main routine
    """
    path_data = r'./test_data/'
    path_output = None
    drift_lookup = {'none': 0, 'netadj': 1, 'roman': 2, 'continuous': 3}
    obsTreeModel = ObsTreeModel()
    previous_loop = None
    previous_survey = None
    vertical_gradient_interval = 64.2
    workspace_loaded = False
    DPI = 60  # resolution for data plots
    all_survey_data = None

    # PyQt indexes
    index_current_survey = None
    index_current_loop = None
    index_current_station = None
    index_current_loop_survey = None
    index_current_station_loop = None
    index_current_station_survey = None

    gui_obstreeview_popup_menu = None
    menus, selection_model = None, None
    tab_data, tab_drift, tab_adjust = None, None, None
    station_model = None
    workspace_savename = None

    DOWN = 1
    UP = -1

    def __init__(self, splash=None):
        super(MainProg, self).__init__()

        self.menus = Menus(self)
        # self.setGeometry(50, 50, 350, 300)
        self.setWindowTitle('GSadjust')

        # tab_....s are populated with GUI elements in the tab_...() functions
        self.tab_data = TabData(self)
        self.tab_drift = TabDrift(self)
        self.tab_adjust = TabAdjust(self)
        self.tab_widget = QtWidgets.QTabWidget()

        self.tab_widget = QtWidgets.QTabWidget()
        self.tab_widget.addTab(self.tab_data, 'Data')
        self.tab_widget.addTab(self.tab_drift, 'Drift')
        self.tab_widget.addTab(self.tab_adjust, 'Network Adjustment')
        self.tab_widget.setStyleSheet("QTabBar::tab { font-size: 12pt; height: 40px; width: 250px }")
        self.tab_widget.currentChanged.connect(self.tab_changed)

        self.gui_treeview_widget = QtWidgets.QWidget()
        self.gui_treeview_box = QtWidgets.QVBoxLayout()
        self.gui_data_treeview = QtWidgets.QTreeView()

        self.qtaction_move_station_up = QtWidgets.QAction(QtGui.QIcon('./gsadjust/resources/up.png'), 'Move survey up', self)
        self.qtaction_move_station_up.triggered.connect(slot=lambda: self.move_survey(self.UP))
        self.qtaction_move_station_down = QtWidgets.QAction(QtGui.QIcon('./gsadjust/resources/down.png'), 'Move survey down',
                                                            self)
        self.qtaction_move_station_down.triggered.connect(slot=lambda: self.move_survey(self.DOWN))
        self.gui_toolbar = QtWidgets.QToolBar()
        self.gui_toolbar.addAction(self.qtaction_move_station_up)
        self.gui_toolbar.addAction(self.qtaction_move_station_down)

        self.qtaction_collapse_all = QtWidgets.QAction(QtGui.QIcon('./gsadjust/resources/ca.png'), 'Collapse all', self)
        self.qtaction_collapse_all.triggered.connect(slot=self.gui_data_treeview.collapseAll)
        self.qtaction_expand_all = QtWidgets.QAction(QtGui.QIcon('./gsadjust/resources/ea.png'), 'Expand all', self)
        self.qtaction_expand_all.triggered.connect(slot=self.gui_data_treeview.expandAll)

        self.gui_toolbar.addAction(self.qtaction_collapse_all)
        self.gui_toolbar.addAction(self.qtaction_expand_all)
        self.gui_toolbar.addAction(self.menus.mnAdjAdjustCurrent)
        self.gui_toolbar.addAction(self.menus.mnAdjAdjust)

        self.gui_treeview_box.addWidget(self.gui_toolbar)
        self.gui_treeview_box.addWidget(self.gui_data_treeview)
        self.gui_treeview_widget.setLayout(self.gui_treeview_box)

        self.gui_main_window_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        self.gui_main_window_splitter.addWidget(self.gui_treeview_widget)
        self.gui_main_window_splitter.addWidget(self.tab_widget)
        self.setCentralWidget(self.gui_main_window_splitter)

        # Setup statusbar icons
        self.update_deltas_text = QtWidgets.QLabel("Update delta table:", self)
        self.update_adjust_text = QtWidgets.QLabel("    Update adjustment:", self)
        self.update_not_needed_icon = QtGui.QPixmap('./gsadjust/resources/ico3.png')
        self.update_adjust_icon = QtGui.QPixmap('./gsadjust/resources/ico2.png')
        self.update_deltas_icon = QtGui.QPixmap('./gsadjust/resources/ico1.png')
        self.label_adjust_update_required = QtWidgets.QLabel()
        self.label_deltas_update_required = QtWidgets.QLabel()

        self.statusBar().addPermanentWidget(self.update_deltas_text)
        self.statusBar().addPermanentWidget(self.label_deltas_update_required)
        self.statusBar().addPermanentWidget(self.update_adjust_text)
        self.statusBar().addPermanentWidget(self.label_adjust_update_required)

        self.adjust_update_required()
        self.deltas_update_required()

        # Right-click tree view context menu
        self.menus.mnDeleteSurvey = self.menus.create_action('Delete survey', slot=self.delete_selected)
        self.menus.mnDeleteLoop = self.menus.create_action('Delete loop', slot=self.delete_selected)
        self.menus.mnLoopProperties = self.menus.create_action('Loop properties', slot=self.properties_loop)
        self.menus.mnStationRename = self.menus.create_action('Rename station', slot=self.rename_station)
        self.menus.mnStationDelete = self.menus.create_action('Delete station(s)', slot=self.delete_station)
        self.menus.mnStationDuplicate = self.menus.create_action('Duplicate station', slot=self.duplicate_station)
        self.menus.mnDataNewLoop = self.menus.create_action('Move stations to new loop', slot=self.new_loop)
        self.menus.mnLoopAnimate = self.menus.create_action('Animate loop', slot=self.animate_loop)

        # self.resize(600,800)
        self.path_install = os.getcwd()
        # QtWidgets.QMessageBox.information(self, "xxx", self.install_dir)

    def init_gui(self):
        """
        Called after loading a data file.
        """
        # Left panel: tree with data hierarchy (surveys, loops, stations)
        self.obsTreeModel.setHorizontalHeaderLabels(['Name', 'Date', 'g (\u00b5Gal)'])

        # Enable menus
        self.menus.set_state(MENU_STATE.INIT)

        # Resize, expand tree view
        self.gui_data_treeview.setModel(self.obsTreeModel)
        self.obsTreeModel.dataChanged.connect(self.on_obs_checked_change)
        self.obsTreeModel.signal_refresh_view.connect(self.refresh_tables)
        self.obsTreeModel.signal_name_changed.connect(self.deltas_update_required)
        self.obsTreeModel.signal_delta_update_required.connect(self.deltas_update_required)
        self.selection_model = self.gui_data_treeview.selectionModel()
        self.selection_model.selectionChanged.connect(self.on_obs_tree_change)
        # self.data_treeview.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)

        self.gui_data_treeview.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.gui_data_treeview.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.gui_data_treeview.customContextMenuRequested.connect(self.treeview_context_menu)
        self.gui_data_treeview.setItemDelegate(BoldDelegate(self))
        self.gui_data_treeview.doubleClicked.connect(self.activate_survey_or_loop)
        self.gui_data_treeview.setObjectName('data')
        self.gui_data_treeview.setEditTriggers(QtWidgets.QTreeView.EditKeyPressed)
        self.gui_data_treeview.setExpandsOnDoubleClick(False)
        self.gui_data_treeview.expandAll()
        self.gui_data_treeview.resizeColumnToContents(0)
        self.gui_data_treeview.resizeColumnToContents(1)
        self.gui_data_treeview.resizeColumnToContents(2)

        # Highlight first tree-view item
        obstreesurvey = self.obsTreeModel.itemFromIndex(self.obsTreeModel.index(0, 0))
        obstreeloop = obstreesurvey.child(0)
        station = obstreeloop.child(0)

        # Set current keys
        self.index_current_survey = obstreesurvey.index()
        self.index_current_loop = obstreeloop.index()
        self.index_current_loop_survey = obstreesurvey.index()
        self.index_current_station_loop = obstreeloop.index()
        self.index_current_station_survey = obstreesurvey.index()
        self.index_current_station = station.index()

        # Activate first tree view item
        self.activate_survey_or_loop(self.index_current_loop)
        self.activate_survey_or_loop(self.index_current_survey)

        # Set data plot
        self.plot_samples()
        # self.selmodel.select(station.index(), QtCore.QItemSelectionModel.SelectCurrent)
        self.gui_data_treeview.setFocus()

    def adjust_update_required(self):
        """
        Updates status bar icon
        """
        self.label_adjust_update_required.set = True
        self.label_adjust_update_required.setPixmap(self.update_adjust_icon)
        self.label_adjust_update_required.setToolTip('Update network adjustment')
        self.set_window_title_asterisk()

    def adjust_update_not_required(self):
        """
        Updates status bar icon
        """
        self.label_adjust_update_required.set = False
        self.label_adjust_update_required.setPixmap(self.update_not_needed_icon)
        self.label_adjust_update_required.setToolTip('Network adjustment is up to date')

    def deltas_update_required(self):
        """
        Updates status bar icon
        """
        self.label_deltas_update_required.set = True
        self.label_deltas_update_required.setPixmap(self.update_deltas_icon)
        self.label_deltas_update_required.setToolTip('Update delta table')
        self.set_window_title_asterisk()

    def deltas_update_not_required(self):
        """
        Updates status bar icon
        """
        self.label_deltas_update_required.set = False
        self.label_deltas_update_required.setPixmap(self.update_not_needed_icon)
        self.label_deltas_update_required.setToolTip('Delta table is up to date')

    def tab_changed(self, new_idx):
        """
        Updates tab plots/tables as needed. These typically aren't updated unless they're visible.
        :param new_idx: Index of newly-selected tab.
        """
        if new_idx == 0:
            self.plot_samples()
        if new_idx == 1:
            self.update_drift_tables_and_plots()

    def plot_samples(self):
        """
        Get station to plot, update station table model if necessary.
        """
        # Center panel: table (station values)
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreeloop = obstreestation.parent()
        station = obstreestation
        if obstreeloop.meter_type == 'Scintrex' \
                or obstreeloop.meter_type == 'CG6' \
                or obstreeloop.meter_type == 'csv' \
                or obstreeloop.meter_type == 'CG6Tsoft':
            self.station_model = ScintrexTableModel(station)
        elif obstreeloop.meter_type == 'Burris':
            self.station_model = BurrisTableModel(station)
        self.station_model.dataChanged.connect(self.plot_samples)
        self.station_model.signal_update_coordinates.connect(self.populate_station_coords)
        self.station_model.signal_adjust_update_required.connect(self.adjust_update_required)
        self.station_model.signal_uncheck_station.connect(self.uncheck_station)
        self.station_model.signal_check_station.connect(self.check_station)
        self.tab_data.data_view.setModel(self.station_model)
        self.obsTreeModel.dataChanged.emit(QtCore.QModelIndex(), QtCore.QModelIndex())
        self.tab_data.update_station_plot(station, obstreeloop.meter_type)

    def uncheck_station(self):
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreestation.setCheckState(0)

    def check_station(self):
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreestation.setCheckState(2)

    ###########################################################################
    # Load/Open/Save routines
    ###########################################################################
    def open_file_dialog(self, open_type):
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(caption='Open file', directory=self.path_data)
        if fname:
            self.open_raw_data(fname, open_type)

    def open_raw_data(self, fname, open_type):
        """
        - Display a file opening window
        - Populate obsTreeModel
        :param open_type: 'choose' - if appending a survey to campaign
                           'chooseloop' - if appending loop to survey
                           'CG6', 'Burris', or 'Scintrex' - reading a raw data file
        """
        # open file
        append_loop = False
        if 'loop' in open_type:
            append_loop = True

        # The case when "append survey' or 'append loop' is called: accomadate the rare instance of combining meter
        # types on a survey
        if 'choose' in open_type:
            meter_type_dialog = MeterType()
            test = meter_type_dialog.exec_()
            if test < 5:  # 5 = cancel  (accept/reject not working?)
                meter_type = meter_type_dialog.meter_type
            else:
                return

        # Otherwise, 'Load raw....' was called. We know the meter type, but need to ask about appending or overwriting
        # the existing data (only if there is existing data).
        elif self.obsTreeModel.invisibleRootItem().rowCount() > 0:
            overwrite_tree_dialog = Overwrite()
            if overwrite_tree_dialog.exec_():
                self.workspace_clear()
            else:
                return

        if 'choose' not in open_type:
            meter_type = open_type

        if fname[-2:] == '.p':
            self.msg = show_message('Please use "Open workspace... " to load a .p file', 'File load error')
            return

        if fname:
            self.path_output = os.path.dirname(fname)
            logging.info('Loading data file: %s', fname)
            self.path_data = os.path.dirname(str(fname))

            # populate a Campaign object
            err = None
            try:
                self.all_survey_data = self.read_raw_data_file(fname, meter_type)
                if append_loop:
                    obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
                    # Loads all survey data into a single loop.
                    obstreesurvey.populate(self.all_survey_data, name=str(obstreesurvey.loop_count))
                else:
                    obstreesurvey = ObsTreeSurvey(str(num2date(self.all_survey_data.t[0]).date()))
                    obstreesurvey.populate(self.all_survey_data)
                    self.obsTreeModel.appendRow([obstreesurvey, QtGui.QStandardItem('a'), QtGui.QStandardItem('a')])
            except IOError as e:
                self.msg = show_message('No file : {}'.format(fname), 'File error')
            except ValueError as e:
                self.msg = show_message('Value error at line {:d}. Check raw data file: possible bad value?'.
                                        format(e.i), 'File error')
            except IndexError as e:
                self.msg = show_message('Index error at line {:d}. Check raw data file: possible missing value?'.
                                        format(e.i), 'File error')
            if err:
                logging.exception(err, exc_info=True)

            if open_type not in 'choose':
                self.init_gui()
            self.plot_samples()
            # if open_type == 'Burris' or open_type == 'CG6' or open_type == 'csv':
            if open_type is not 'Scintrex':
                self.populate_station_coords()
            self.workspace_loaded = True
            QtWidgets.QApplication.restoreOverrideCursor()
            self.set_window_title_asterisk()
            QtWidgets.QApplication.processEvents()
        else:
            return False

    @staticmethod
    def read_raw_data_file(filename, meter_type):
        """
        Read raw relative-gravity text file in the format exported from meter (Scintrex or Burris). Data are returned to
        the calling function.
        :param filename: Full path to import file
        :param meter_type: 'Burris' or 'Scintrex'
        :return all_survey_data: ChannelList object with all survey data
        """
        i = 0
        try:
            all_survey_data = ChannelList()
            with open(filename, 'r') as fh:
                logging.info("number of lines: {:d}".format(len([1 for line in open(filename, 'r')])))
                all_survey_data.meter_type = meter_type
                # TODO: make meter-specific code separate methods. This is clunky, but maintains flexibility
                if meter_type == 'csv':
                    _ = fh.readline()
                    all_survey_data = read_csv(fh)
                elif meter_type == 'Scintrex':
                    all_survey_data = read_scintrex(fh)
                elif meter_type == 'Burris':
                    all_survey_data = read_burris(fh)
                elif meter_type == 'CG6':
                    all_survey_data = read_cg6(fh)
                elif meter_type == 'CG6Tsoft':
                    all_survey_data = read_cg6tsoft(fh)

                return all_survey_data

        # Returning e like this allows exceptions to be tested in pytest
        except IOError:
            raise
        except ValueError as e:
            e.i = i
            raise e
        except IndexError as e:
            e.i = i
            raise e

    def workspace_append(self):
        """
        Append previously-saved workspace to current workspace.
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open File', self.path_data)
        if fname[-1] is 'p':
            self.msg = show_message('If trying to append a .p file, please save it as a .gsa file first.',
                                    'Import error')
            return
        obstreesurveys, delta_models, coords = self.obsTreeModel.load_workspace(fname)
        # TODO: Do something with coords (append to table if not already there)
        for survey in obstreesurveys:
            self.obsTreeModel.appendRow([survey,
                                         QtGui.QStandardItem('0'),
                                         QtGui.QStandardItem('0')])
        self.update_all_drift_plots()
        self.populate_station_coords()
        self.workspace_loaded = True
        self.populate_survey_deltatable_from_simpledeltas(delta_models, obstreesurveys)
        QtWidgets.QApplication.restoreOverrideCursor()
        self.set_window_title_asterisk()

    def workspace_clear(self):
        """
        Clears all models and refreshes view.
        """
        logging.info("Workspace cleared")
        self.obsTreeModel = ObsTreeModel()
        self.gui_data_treeview.setModel(None)
        self.gui_data_treeview.update()
        self.tab_data.clear_axes()
        self.tab_data.data_view.setModel(None)
        self.tab_data.data_view.update()
        self.tab_drift.delta_view.setModel(None)
        self.tab_drift.delta_view.update()
        self.tab_drift.dg_samples_view.setModel(None)
        self.tab_drift.dg_samples_view.update()
        self.tab_drift.clear_axes()
        self.tab_adjust.delta_view.setModel(None)
        self.tab_adjust.delta_view.update()
        self.tab_adjust.datum_view.setModel(None)
        self.tab_adjust.datum_view.update()
        self.tab_adjust.results_view.setModel(None)
        self.tab_adjust.results_view.update()
        self.tab_adjust.textAdjResults.clear()

        self.menus.set_state(MENU_STATE.CLEAR)
        self.setWindowTitle('GSadjust')

    def workspace_save(self):
        """
        Saves data if a workspace has already been saved
        """
        if self.label_deltas_update_required.set is True:
            self.msg = show_message(
                'Workspace cannot be saved while the Relative-gravity differences table on the Network ' +
                'Adjustment tab is not up to date.', 'Workspace save error')
            return False
        fname = self.obsTreeModel.save_workspace(self.workspace_savename)
        if fname:
            self.msg = show_message('Workspace saved', '')
            self.set_window_title(fname)
            return True
        else:
            self.msg = show_message("Workspace save error", "Error")
            return False

    def workspace_save_as(self):
        """
        Saves data object using pickle.dump()
        """
        if self.label_deltas_update_required.set is True:
            self.msg = show_message(
                'Workspace cannot be saved while the Relative-gravity differences table on the Network ' +
                'Adjustment tab is not up to date.', 'Workspace save error')
        else:
            try:
                fname, _ = QtWidgets.QFileDialog.getSaveFileName(None, 'Save workspace as', self.path_data)
                if fname:
                    save_name = self.obsTreeModel.save_workspace(fname)
                    if save_name:
                        self.set_window_title(fname)
                        self.msg = show_message('Workspace saved', '')
                        self.workspace_savename = fname
                        self.menus.set_state(MENU_STATE.ACTIVE_WORKSPACE)
                    else:
                        self.msg = show_message("Workspace save error", "Error")

            except Exception as e:
                self.msg = show_message("Workspace save error", "Error")
                logging.exception(e, exc_info=True)
                self.menus.set_state(MENU_STATE.ACTIVE_WORKSPACE)

    def workspace_open_getfile(self):
        """
        Gets filename to open and asks whether to  append or overwrite, if applicable.
        :return:
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open File', self.path_data)
        if fname:
            if fname[-2:] != '.p':
                self.msg = show_message('Saved workspaces should have a .p or .gsa extension. ' +
                                        'Please use "Open workspace..." to load a .gsa file, or ' +
                                        '"Open raw...data" to load a data file.', 'File load error')
                return

            if self.obsTreeModel.invisibleRootItem().rowCount() > 0:
                overwrite_tree_dialog = Overwrite()
                if overwrite_tree_dialog.exec_():
                    self.workspace_clear()
                    self.workspace_open(fname)
                else:
                    return
            else:
                self.workspace_open(fname)

        self.path_data = os.path.dirname(str(fname))

    def workspace_open_getjson(self):
        """
        Gets filename to open and asks whether to  append or overwrite, if applicable.
        :return:
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open File', self.path_data)
        if fname:
            if fname[-4:] != '.gsa':
                self.msg = show_message('Saved workspaces should have a .gsa extension. ' +
                                        'Please use "Open raw...data" to load a data file' +
                                        ' or "Open workspace (.p format)" to open a workspace' +
                                        ' with .p extension.', 'File load error')
                return

            if self.obsTreeModel.invisibleRootItem().rowCount() > 0:
                overwrite_tree_dialog = Overwrite()
                if overwrite_tree_dialog.exec_():
                    self.workspace_clear()
                    self.workspace_open_json(fname)
                else:
                    return
            else:
                self.workspace_open_json(fname)
        self.path_data = os.path.dirname(str(fname))

    def workspace_open_json(self, fname):
        """
        Loads data from JSON file. Restores PyQt tables to Survey object
        """
        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        # Returns list of survey delta tables so they can be passed to populate_survey_deltatable_from_simpledeltas()
        # try:
        QtWidgets.QApplication.processEvents()
        obstreesurveys, delta_models, coords = self.obsTreeModel.load_workspace(fname)
        if obstreesurveys:
            self.workspace_savename = fname
            self.populate_obstreemodel(obstreesurveys, delta_models)
            self.set_window_title(fname)
        if coords:
            self.obsTreeModel.station_coords = coords

    def workspace_open(self, fname):
        """
        Loads data from pickle file. Restores PyQt tables to Survey object (PyQt tables can't be
        pickled and are removed in workspace_save).
        """
        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        # Returns list of survey delta tables so they can be passed to populate_survey_deltatable_from_simpledeltas()
        # try:
        QtWidgets.QApplication.processEvents()
        obstreesurveys, delta_models, coords = self.obsTreeModel.load_workspace_p(fname)
        if obstreesurveys:
            self.workspace_savename = fname
            self.populate_obstreemodel(obstreesurveys, delta_models)
            self.set_window_title(fname)
        if coords:
            self.obsTreeModel.station_coords = coords

    def populate_obstreemodel(self, obstreesurveys, delta_models):
        pbar = ProgressBar(total=6, textmess='Loading workspace')
        pbar.show()
        pbar.progressbar.setValue(1)
        for survey in obstreesurveys:
            self.obsTreeModel.appendRow([survey,
                                         QtGui.QStandardItem('0'),
                                         QtGui.QStandardItem('0')])
        pbar.progressbar.setValue(2)
        QtWidgets.QApplication.processEvents()
        if not delta_models:
            QtWidgets.QApplication.restoreOverrideCursor()
            return
        else:
            i = 0
            firststation = None
            # This avoids an error when the first loop (or subsequent loops) are empty
            firstsurvey = self.obsTreeModel.itemFromIndex(self.obsTreeModel.index(0, 0))
            while firststation is None:
                firstloop = firstsurvey.child(i)
                firststation = firstloop.child(0)
                i += 1
            pbar.progressbar.setValue(3)
            QtWidgets.QApplication.processEvents()
            self.index_current_survey = firstsurvey.index()
            self.index_current_loop = firstloop.index()
            self.index_current_station = firststation.index()
            self.index_current_loop_survey = firstsurvey.index()
            self.index_current_station_loop = firstloop.index()
            self.index_current_station_survey = firstsurvey.index()
            try:
                self.populate_station_coords()
            except Exception as e:
                # sometimes coordinates aren't valid
                pass

            self.menus.set_state(MENU_STATE.ACTIVE_WORKSPACE, MENU_STATE.OBS_TREE_MODEL)

            self.workspace_loaded = True
            self.update_all_drift_plots()
            pbar.progressbar.setValue(4)
            QtWidgets.QApplication.processEvents()
            # The deltas on the survey delta table (on the network adjustment tab) aren't pickled. When loading a
            # workspace, the loop deltas first have to be created by update_all_drift_plots(), then the survey delta
            # table can be updated.
            self.populate_survey_deltatable_from_simpledeltas(delta_models, obstreesurveys)
            # for survey in obstreesurveys:
            #     self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)
            self.update_adjust_tables()
            pbar.progressbar.setValue(5)
            QtWidgets.QApplication.processEvents()
            self.init_gui()
            self.deltas_update_not_required()
            QtWidgets.QApplication.restoreOverrideCursor()
            pbar.progressbar.setValue(6)
            pbar.close()
        # except Exception as e:
        #     self.msg = show_message("Workspace load error", "Error")

    def populate_survey_deltatable_from_simpledeltas(self, delta_models, surveys):
        deltas = assemble_all_deltas(self.obsTreeModel)
        for idx, delta_model in enumerate(delta_models):
            for simpledelta in delta_model:
                if not hasattr(simpledelta, 'loop'):
                    simpledelta.loop = None
                i = 0
                try:
                    if simpledelta.type == 'normal':
                        if type(simpledelta) == SimpleDelta:
                            station1 = surveys[idx].return_obstreestation(simpledelta.sta1)
                            station2 = surveys[idx].return_obstreestation(simpledelta.sta2)
                            if station1 is not None and station2 is not None:
                                d = Delta(station1, station2,
                                          adj_sd=simpledelta.adj_sd,
                                          driftcorr=simpledelta.driftcorr,
                                          ls_drift=simpledelta.ls_drift,
                                          delta_type=simpledelta.type,
                                          checked=simpledelta.checked,
                                          loop=simpledelta.loop)
                            else:
                                logging.error('Delta recreation error')
                        # For dealing with old-style .p workspaces
                        elif type(simpledelta) == Delta:
                            d = simpledelta
                    elif simpledelta.type == 'list':
                        if not hasattr(simpledelta, 'key'):
                            list_of_deltas = []
                            for delta in simpledelta.sta2:
                                station1 = surveys[idx].return_obstreestation(delta[0])
                                station2 = (surveys[idx].return_obstreestation(delta[1]),
                                            surveys[idx].return_obstreestation(delta[2]))
                                tpd = Delta(station1, station2,
                                            adj_sd=simpledelta.adj_sd,
                                            driftcorr=simpledelta.driftcorr,
                                            ls_drift=simpledelta.ls_drift,
                                            delta_type='three_point',
                                            checked=simpledelta.checked,
                                            loop=simpledelta.loop)
                                list_of_deltas.append(tpd)
                            d = Delta.from_list(list_of_deltas)
                        # This section is necessary to load older .p versions. It's much slower than the above section.
                        else:
                            try:
                                d = return_delta_given_key(simpledelta.key, deltas)
                            except:
                                return
                    elif simpledelta.type == 'assigned':
                        station1 = surveys[idx].return_obstreestation(simpledelta.sta1)
                        station2 = surveys[idx].return_obstreestation(simpledelta.sta2)
                        d = Delta(station1, station2,
                                  adj_sd=simpledelta.adj_sd,
                                  driftcorr=simpledelta.driftcorr,
                                  ls_drift=simpledelta.ls_drift,
                                  delta_type=simpledelta.type,
                                  checked=simpledelta.checked,
                                  loop=simpledelta.loop)
                        d.assigned_dg = simpledelta.assigned_dg
                    if d:
                        i += 1
                        surveys[idx].delta_model.insertRows(d, 0)
                    else:  # unable to create delta
                        self.msg = show_message('Import error',
                                                'Error populating delta table. Please update delta '
                                                               'table on Adjust tab',)
                except:
                    self.msg = show_message('Import error', 'Import error')

    def populate_station_coords(self):
        """
        Stores a single set of coordinates for each station with the obsTreeModel object. The coordinates of the last
        Station in the Survey > Loop > Station hierarchy are used.

        Used as a slot for the self.station_model.signal_update_coordinates signal (thus init_station_coords can't
        be called directly)
        """
        self.obsTreeModel.station_coords = init_station_coords_dict(self.obsTreeModel)

    ###########################################################################
    # General routines
    ###########################################################################
    def populate_deltamodel(self, populate_type):
        """
        Called from menu item
        :param populate_type: 'all', 'selectedLoop', or 'selectedSurvey'
        """
        table_updated = False
        if populate_type == 'all':
            for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                survey = self.obsTreeModel.invisibleRootItem().child(i)
                table_updated = survey.populate_delta_model(clear=True)
                self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

            # item = self.obsTreeModel.invisibleRootItem()
        elif populate_type == 'selectedsurvey':
            survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            table_updated = survey.populate_delta_model(clear=True)
            self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

        elif populate_type == 'selectedloop':
            selected_idx = self.gui_data_treeview.selectedIndexes()
            # There may be one, or multiple loops selected. If only one is selected, we'll populate the delta table
            # based on the currentLoopIndex (which will be in bold but not necessarily highlighted).
            if len(selected_idx) >= 4:
                selected_items = []
                for i in selected_idx:
                    selected_items.append(self.obsTreeModel.itemFromIndex(i))
                # selected_items will contain 3 entries for every tree view item (one for the name, plus 2 for
                # g and std. dev. First, decimate to just the name entries
                selected_items = selected_items[::3]
                loops = [item for item in selected_items if type(item) == ObsTreeLoop]
                first = True
                for loop in loops:
                    survey = loop.parent()
                    if first:
                        table_updated = survey.populate_delta_model(loop, clear=True)
                        first = False
                    else:
                        table_updated = survey.populate_delta_model(loop, clear=False)
            else:
                loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
                survey = loop.parent()
                table_updated = survey.populate_delta_model(loop, clear=True)
            self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

        if table_updated:
            self.deltas_update_not_required()
            self.adjust_update_required()
            self.update_adjust_tables()

        self.menus.set_state(MENU_STATE.DELTA_MODEL)

    def activate_survey_or_loop(self, index):
        """
        Highlights active survey or loop in tree view.
        :param index: PyQt index of newly-highlighted tree item, sent by doubleClicked event
        """
        item = self.obsTreeModel.itemFromIndex(index)
        # If a loop:
        try:
            if type(item) is ObsTreeLoop:
                if self.previous_loop is not None:
                    self.previous_loop.fontweight = QtGui.QFont.Normal
                    self.previous_loop.cellcolor = QtCore.Qt.white
                self.previous_loop = item
                item.cellcolor = QtCore.Qt.lightGray
                item.fontweight = QtGui.QFont.Bold
                # self.update_current_keys(item.keysurv, item.keyloop)
                self.index_current_loop = index
                if self.tab_widget.currentIndex() == 1:
                    self.update_drift_tables_and_plots()

            # If a survey
            elif type(item) is ObsTreeSurvey:
                if self.previous_survey is not None:
                    self.previous_survey.fontweight = QtGui.QFont.Normal
                self.previous_survey = item
                self.index_current_survey = index
                item.fontweight = QtGui.QFont.Bold
                self.update_adjust_tables()
        except Exception as e:
            logging.exception(e, exc_info=True)

        self.obsTreeModel.layoutChanged.emit()

    def set_window_title(self, fname):
        self.setWindowTitle('GSadjust - ' + fname)

    def set_window_title_asterisk(self):
        title = self.windowTitle()
        last_char = title[-1]
        if last_char != '*':
            title += '*'
        self.setWindowTitle(title)

    def update_all_drift_plots(self):
        """
        Updates drift_tab plots and delta_models, even if not in view.
        """
        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            survey = self.obsTreeModel.invisibleRootItem().child(i)
            for ii in range(survey.rowCount()):
                loop = survey.child(ii)
                self.index_current_loop = loop.index()
                self.update_drift_tables_and_plots(update=False)

    def update_adjust_tables(self):
        """
        Update delta-g and datum tables after selecting a new survey in the tree view, or after a network adjustment
        """
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        try:
            survey.delta_model.signal_adjust_update_required.connect(self.adjust_update_required)
            survey.datum_model.signal_adjust_update_required.connect(self.adjust_update_required)
            self.tab_adjust.delta_proxy_model.setSourceModel(survey.delta_model)
            self.tab_adjust.datum_proxy_model.setSourceModel(survey.datum_model)
            self.tab_adjust.results_proxy_model.setSourceModel(survey.results_model)
        except:
            pass
        self.tab_adjust.results_view.setModel(self.tab_adjust.results_proxy_model)
        self.tab_adjust.results_view.setSortingEnabled(True)
        self.tab_adjust.delta_view.setModel(self.tab_adjust.delta_proxy_model)
        self.tab_adjust.datum_view.setModel(self.tab_adjust.datum_proxy_model)
        self.tab_adjust.datum_view.setColumnHidden(4, True)
        self.tab_adjust.datum_view.setColumnHidden(8, True)
        self.tab_adjust.textAdjResults.clear()

        try:
            for line in survey.adjustment.adjustmentresults.text:
                self.tab_adjust.textAdjResults.append(line.strip())
        except:
            pass

        self.refresh_tables()

    def update_drift_tables_and_plots(self, update=True):
        """
        First updates the drift_method combobox, then calls set_drift_method to update plots.
        :param update: Plots are only updated if True. Saves time when loading a workspace.
        """
        drift_method = self.obsTreeModel.itemFromIndex(self.index_current_loop).drift_method
        self.tab_drift.driftmethod_comboboxbox.setCurrentIndex(self.drift_lookup[drift_method])
        self.tab_drift.set_drift_method(update)

    def refresh_tables(self):
        """
        Connected to self.obsTreeModel.refreshView
        """
        self.tab_adjust.delta_proxy_model.beginResetModel()
        self.tab_adjust.delta_proxy_model.endResetModel()
        self.tab_adjust.datum_proxy_model.beginResetModel()
        self.tab_adjust.datum_proxy_model.endResetModel()
        self.tab_adjust.results_proxy_model.beginResetModel()
        self.tab_adjust.results_proxy_model.endResetModel()

    def on_obs_checked_change(self, selected):
        """
        Called when a checkbox state is changed, but not when a new item selected. Should update drift plots
        if on drift tab, but otherwise do nothing.
        :param selected: Selected indexes
        """
        if selected.model() is not None:
            if self.tab_widget.currentIndex() == 1:
                self.update_drift_tables_and_plots()
            elif self.tab_widget.currentIndex() == 2:
                self.adjust_update_required()
                self.tab_adjust.delta_view.update()
                self.tab_adjust.delta_view.repaint()
            self.set_window_title_asterisk()

    def on_obs_tree_change(self, selected):
        """
        Called when the selection model changes.
        :param selected: Selected indexes
        """
        indexes = selected.indexes()
        if indexes:
            item = self.obsTreeModel.itemFromIndex(indexes[0])
            if item:
                if type(item) is ObsTreeStation:
                    self.index_current_station = indexes[0]
                    if self.tab_widget.currentIndex() == 0:
                        self.plot_samples()
                    if self.tab_widget.currentIndex() == 1:
                        self.update_drift_tables_and_plots()

    def adjusted_vs_observed_datum_analysis(self):
        return

    def correction_ocean_loading(self):
        self.msg = show_message('Not implemented', 'Error')

    def correction_atmospheric(self):
        self.msg = show_message('Not implemented', 'Error')

    def correct_recorded_time(self):
        """
        Correct all times from an offset: when GMT time entered in relative gravimeter is bad.
        """
        # ask for time difference to apply

        text, ok = QtWidgets.QInputDialog.getText(self, 'Input parameters',
                                                  'time offset to apply (min)?')
        if ok:
            time_correction_dialog = ApplyTimeCorrection()
            time_correction_dialog.msg.exec_()
            correction_type = time_correction_dialog.time_correction_type
            if correction_type != False:
                time_correction(self.obsTreeModel, int(text), self.index_current_survey, self.index_current_loop, self.gui_data_treeview.selectedIndexes())
                self.set_window_title_asterisk()

    def set_vertical_gradient_interval(self):
        """
        Dialog that queries user for the distance over which vertical gradient is measured.
        """
        interval = VerticalGradientDialog(self.vertical_gradient_interval)
        self.vertical_gradient_interval = interval

    def vertical_gradient_write(self):
        """
        Writes a .grd file with two values: gradient and standard deviation. Only works when Roman drift method
        is used.
        """
        deltamodel = self.tab_drift.delta_view.model()
        if deltamodel.rowCount() == 1:
            stationname = self.obsTreeModel.itemFromIndex(self.index_current_loop).child(0).name
            defaultfile = self.path_data + '/' + stationname + '.grd'
            file_name, _ = QtWidgets.QFileDialog.getSaveFileName(None, 'Vertical gradient file to write',
                                                                 defaultfile)
            if file_name:
                delta = deltamodel.data(deltamodel.index(0, 0), role=QtCore.Qt.UserRole)
                with open(file_name, 'w') as fid:
                    fid.write('{:0.2f}'.format(-1 * delta.dg / self.vertical_gradient_interval))
                    fid.write(' +/- {:0.2f}'.format(delta.sd / self.vertical_gradient_interval))
        else:
            self.msg = show_message("Incorrect number of delta-g's (should be 1; try the Roman method)",
                                    "Vertical gradient error")

    def add_tare(self):
        """
        Opens a dialog to add tare to loop tare_model.
        """
        new_tare_date, new_tare_value = 0, 0
        current_loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        obstreestation = current_loop.child(0)
        default_time = num2date(obstreestation.t[0])
        taredialog = AddTareDialog(default_time)
        if taredialog.exec_():
            new_tare_date = taredialog.dt_edit.dateTime()
            new_tare_value = taredialog.edit_box.text()
        try:
            tare = Tare(new_tare_date.date(), new_tare_date.time(), new_tare_value)
        except:
            return
        if not hasattr(current_loop, 'tare_model'):
            current_loop.tare_model = TareTableModel
        current_loop.tare_model.insertRows(tare)
        self.tab_drift.process_tares(current_loop)
        self.update_drift_tables_and_plots()
        self.set_window_title_asterisk()

    def clear_delta_model(self):
        """
        Remove all deltas from survey delta model shown on network adjustment tab.
        """
        self.obsTreeModel.itemFromIndex(self.index_current_survey).delta_model.clearDeltas()
        self.obsTreeModel.itemFromIndex(self.index_current_survey).results_model.clearResults()
        self.clear_adjustment_test()
        self.deltas_update_required()
        self.update_adjust_tables()
        self.set_window_title_asterisk()

    def clear_adjustment_test(self):
        self.tab_adjust.textAdjResults.clear()
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        survey.adjustment.adjustmentresults.text = []

    def clear_datum_model(self):
        """
        Remove all datums from datum model shown on network adjustment tab.
        :return:
        """
        self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.clearDatums()
        self.obsTreeModel.itemFromIndex(self.index_current_survey).results_model.clearResults()
        self.clear_adjustment_test()
        self.update_adjust_tables()
        self.set_window_title_asterisk()

    def clear_results_model(self):
        """
        Remove all results from results model shown on network adjustment tab.
        """
        self.obsTreeModel.itemFromIndex(self.index_current_survey).results_model.clearResults()
        self.update_adjust_tables()

    def animate_loop(self):
        loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        p = plot_loop_animation(loop)
        return p

    def properties_loop(self):
        """
        Show popup dialog to specify loop properties.
        :return:
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        loops = []
        for idx in indexes:
            if idx.column() == 0:
                loops.append(self.obsTreeModel.itemFromIndex(idx))
        loop_options = LoopOptions(loops, parent=self)
        if loop_options.exec_():
            # Sync new meter numbers with station objects
            # for loop in self.loops:

            for loop in loops:
                loop.oper = loop_options.operator_edit.text()
                loop.meter = loop_options.meter_edit.text()
                loop.comment = loop_options.comment_edit.toPlainText()
                for i in range(loop.rowCount()):
                    obstreestation = loop.child(i)
                    obstreestation.meter = [loop.meter] * len(obstreestation.meter)
                    obstreestation.oper = [loop.oper] * len(obstreestation.oper)
        self.plot_samples()

    def delete_selected(self):
        """
        Remove loop or survey from tree view
        """
        index = self.gui_data_treeview.selectedIndexes()
        self.obsTreeModel.removeRow(index[0].row(), index[0].parent())
        if self.obsTreeModel.invisibleRootItem().rowCount() == 0:
            self.workspace_clear()
        self.set_window_title_asterisk()

    def rename_station(self):
        """
        Rename station; same as F2.
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        if len(indexes) > 3 or len(indexes) == 0:
            return
        # Because each tree item has three columns, len(indexes) equals the number of items selected * 3. The next
        # line takes every 3rd index.
        index = indexes[0]
        trigger = self.gui_data_treeview.EditKeyPressed
        event = None
        self.gui_data_treeview.edit(index, trigger, event)
        self.set_window_title_asterisk()

    def delete_station(self):
        """
        Remove station from tree view
        """
        indexes = self.gui_data_treeview.selectedIndexes()

        # Because each tree item has three columns, len(indexes) equals the number of items selected * 3. The next
        # line takes every 3rd index.
        indexes = indexes[0::3]
        for index in reversed(indexes):
            self.obsTreeModel.removeRow(index.row(), index.parent())
            self.set_window_title_asterisk()
        if index.row() > 0:
            self.index_current_station = index.sibling(index.row() - 1, 0)
        else:
            self.index_current_station = index.sibling(0, 0)

        first_index = indexes[0]
        if first_index.row() > 0:
            row = first_index.row() - 1
        else:
            row = 0
        new_selection_index = self.obsTreeModel.index(row,
                                                      0,
                                                      first_index.parent())
        self.selection_model.select(new_selection_index, QtCore.QItemSelectionModel.SelectCurrent)
        self.plot_samples()

    def delete_tare(self):
        """
        Called when user right-clicks a datum and selects delete from the context menu
        """
        index = self.tab_drift.tare_view.selectedIndexes()
        loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        for idx in reversed(index):
            loop.tare_model.removeRow(idx)
        self.tab_drift.tare_view.update()
        self.tab_drift.process_tares(self.obsTreeModel.itemFromIndex(self.index_current_loop))
        self.update_drift_tables_and_plots()
        self.set_window_title_asterisk()

    def delete_datum(self):
        """
        Called when user right-clicks a datum and selects delete from the context menu
        """
        index = self.tab_adjust.datum_view.selectedIndexes()
        i = [self.tab_adjust.datum_proxy_model.mapToSource(idx) for idx in index]
        i.sort(key=lambda x: x.row(), reverse=True)
        for idx in i:
            survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            survey.datum_model.removeRow(idx)
        self.tab_adjust.datum_view.update()
        self.set_window_title_asterisk()

    def get_loop_threshold(self):
        # Prompt user to select time threshold
        loopdialog = LoopTimeThresholdDialog()
        if loopdialog.exec_():
            loop_thresh = loopdialog.dt_edit.dateTime()
            # Convert to days. Subtract one from the date because the default is 1 (i.e., if the time set in the
            # loop dialog is 8:00, loop thresh is a Qdatetime equal to (2000,1,1,8,0).
            loop_thresh = int(loop_thresh.toString("H")) / 24 + int(loop_thresh.toString("d")) - 1
        else:
            return
        self.divide_survey(loop_thresh)

    def divide_by_height(self):
        """
        Called from "Divide loop..." menu command. Shows a dialog to specify a time interval, then scans the current
        loop and divides station occupations separated by the time interval (or greater) into a loop. Useful primarily
        when several day's data is in a single file.
        """
        # Clear survey delta table, it causes problems otherwise
        self.clear_delta_model()

        # Store the original current loop index so it can be restored.
        original_loop_index = self.index_current_loop

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        obstreeloop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        indexes = []
        if obstreeloop.rowCount() > 1:
            self.msg = show_message("Loop must have a single station to divide by height.", "GSadjust error")
            return

        station = obstreeloop.child(0)
        height = station.height[0]
        height_idx = 0
        n_samples = len(station.height)
        count_dict = dict()
        heights = set(station.height)
        for h in heights:
            count_dict[h] = 0
        for idx, h in enumerate(station.height):
            if h != height or idx == len(station.height) - 1:
                new_station = ChannelList()
                for k, v in station.__dict__.items():
                    try:  # some fields have no len()
                        if len(v) == n_samples:
                            # temp_sta = new_station.extract_subset_idx(height_idx, idx)
                            setattr(new_station, k, v[height_idx:idx])
                        else:
                            setattr(new_station, k, v)
                    except Exception as e:
                        continue

                # new_station = 0
                # # obstreestation = self.obsTreeModel.itemFromIndex(index)
                # new_station_count = float(obstreestation.station_count) + 0.1
                if height == 0:
                    name = station.station_name
                else:
                    name = station.station_name + "_{:.3f}".format(height)
                new_obstreestation = ObsTreeStation(new_station, name, "{}".format(int(count_dict[height])))
                count_dict[height] += 1
                obstreeloop.appendRow([new_obstreestation,
                                       QtGui.QStandardItem('a'),
                                       QtGui.QStandardItem('a')])
                height_idx = idx
                height = h

        obstreeloop.removeRow(0)
        self.index_current_station = obstreeloop.child(0).index()
        # self.index_current_loop = original_loop_index
        self.update_drift_tables_and_plots()
        self.deltas_update_required()
        self.obsTreeModel.layoutChanged.emit()
        QtWidgets.QApplication.restoreOverrideCursor()
        self.set_window_title_asterisk()

    def divide_survey(self, loop_thresh):
        """
        Called from "Divide loop..." menu command. Shows a dialog to specify a time interval, then scans the current
        loop and divides station occupations separated by the time interval (or greater) into a loop. Useful primarily
        when several day's data is in a single file.
        """
        # Clear survey delta table, it causes problems otherwise
        self.clear_delta_model()

        # Store the original current loop index so it can be restored.
        original_loop_index = self.index_current_loop

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        obstreeloop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        indexes = []
        pbar = ProgressBar(total=obstreeloop.rowCount() - 1, textmess='surveys')
        pbar.show()
        pbar.progressbar.setValue(1)
        QtWidgets.QApplication.processEvents()
        # Step through loop backward
        pbar_idx = list(range(obstreeloop.rowCount()))
        pbar_idx.reverse()
        for i in range(obstreeloop.rowCount() - 1, 1, -1):
            station2 = obstreeloop.child(i)
            station1 = obstreeloop.child(i - 1)
            pbar.progressbar.setValue(pbar_idx[i])
            QtWidgets.QApplication.processEvents()
            # Check time difference between successive stations
            tdiff = station2.tmean - station1.tmean
            if tdiff > loop_thresh:
                for ii in range(i, obstreeloop.rowCount()):
                    indexes.append(obstreeloop.child(ii).index())
                self.new_loop_from_indexes(indexes)
                indexes = []
        self.index_current_loop = original_loop_index
        self.update_drift_tables_and_plots()
        self.deltas_update_required()
        self.obsTreeModel.layoutChanged.emit()
        QtWidgets.QApplication.restoreOverrideCursor()
        self.set_window_title_asterisk()

    def duplicate_station(self):
        """
        Create a duplicate of a station in the tree view. Useful when the same station is observed at the end of one
        day and the start of the next day: when imported, it will appear as one station, but it should be two.
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        if len(indexes) > 3:
            self.msg = show_message("Please select a single station when duplicating.", "GSadjust error")
            return
        index = indexes[0]
        model = indexes[0].model()
        obstreeloop = model.itemFromIndex(indexes[0].parent())
        obstreesurvey = obstreeloop.parent()
        obstreestation = self.obsTreeModel.itemFromIndex(index)
        new_station_count = float(obstreestation.station_count) + 0.1
        new_obstreestation = ObsTreeStation(obstreestation, obstreestation.station_name, "{:.1f}".format(new_station_count))

        obstreeloop.insertRow(index.row() + 1, [new_obstreestation,
                                                QtGui.QStandardItem('a'),
                                                QtGui.QStandardItem('a')])
        logging.info("Station duplicated: {}, Survey: {}, Loop: {} ".format(new_obstreestation.station_name,
                                                                            obstreesurvey.name,
                                                                            obstreeloop.name))
        self.set_window_title_asterisk()

    def move_survey(self, direction=UP):
        """
        Used to move survey up or down in the tree view
        :param direction: self.UP or self.DOWN (macros for 1 and -1)
        :return:
        """
        if direction not in (self.DOWN, self.UP):
            return

        model = self.obsTreeModel
        index = self.index_current_survey
        row_number = index.row()
        new_row = row_number + direction
        if not (0 <= new_row < model.rowCount()):
            return False
        survey = model.takeRow(row_number)
        model.insertRow(new_row, survey)
        self.index_current_survey = model.indexFromItem(survey[0])
        self.set_window_title_asterisk()
        return True

    def new_loop(self):
        """
        Creates a new loop in tree view
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        self.new_loop_from_indexes(indexes)
        self.activate_survey_or_loop(self.index_current_loop)
        self.update_drift_tables_and_plots(update=True)
        self.plot_samples()
        self.set_window_title_asterisk()

    def new_loop_from_indexes(self, indexes):
        """
        Moves stations at the specified indexes to a new loop.
        :param indexes: PyQt indexes of selected stations
        """
        if len(indexes) > 0:
            model = indexes[0].model()
            obstreeloop = model.itemFromIndex(indexes[0].parent())
            obstreesurvey = obstreeloop.parent()
            new_loop_name = str(obstreesurvey.rowCount())
            # new loop, increment from loop parent
            new_obstreeloop = ObsTreeLoop(new_loop_name)

            # iterate over indexes
            # For whatever reason we can't just appendRow the 'itemFromIndex' directly. Instead, have to make a new
            # ObsTreeItem and append that. Probably has to do with needing to call the __init__ method of the PyQt obj.
            logging.info('Loop {} added'.format(new_loop_name))
            first = True
            for idx in indexes:
                if idx.column() == 0:
                    obstreestation = model.itemFromIndex(idx)
                    new_obstreestation = ObsTreeStation(obstreestation,
                                                        obstreestation.station_name,
                                                        obstreestation.station_count)
                    logging.info('Station added to new loop: {}'.format(
                        obstreestation.name))
                    new_obstreeloop.appendRow([new_obstreestation,
                                               QtGui.QStandardItem('a'),
                                               QtGui.QStandardItem('a')])
                if first:
                    new_obstreeloop.meter = obstreestation.meter[0]

                    first = False
            for idx in reversed(indexes):
                if idx.column() == 0:
                    self.obsTreeModel.beginRemoveRows(idx.parent(), idx.row(), idx.row() + 1)
                    self.obsTreeModel.removeRow(idx.row(), idx.parent())
                    self.obsTreeModel.endRemoveRows()
            obstreesurvey.appendRow(new_obstreeloop)
            self.gui_data_treeview.expand(new_obstreeloop.index())
            self.obsTreeModel.layoutChanged.emit()
            self.index_current_loop = new_obstreeloop.index()
            self.index_current_station = obstreeloop.child(0, 0).index()
            self.set_window_title_asterisk()

    def treeview_context_menu(self, point):
        """
        Right-click context menu on tree view
        """
        self.gui_data_treeview_popup_menu = QtWidgets.QMenu("Menu", self)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDeleteSurvey)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDeleteLoop)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnLoopProperties)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnStationRename)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnStationDelete)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnStationDuplicate)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDataNewLoop)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnLoopAnimate)
        # enable as appropriate
        indexes = self.gui_data_treeview.selectedIndexes()
        if indexes:
            index = indexes[0]
            item = index.model().itemFromIndex(index)
            if type(item) is ObsTreeStation:
                self.menus.set_state(MENU_STATE.OBS_TREE_STATION)
            elif type(item) is ObsTreeLoop or type(item) is ObsTreeSurvey:
                self.menus.set_state(MENU_STATE.OBS_TREE_LOOP_OR_SURVEY)

            self.gui_data_treeview_popup_menu.exec_(self.gui_data_treeview.mapToGlobal(point))

    def adjust_network(self, how_many='all'):
        """
        Carries out network adjustment, updates output tables
        """
        if self.menus.mnAdjPyLSQ.isChecked():
            adj_type = 'PyLSQ'
        else:
            adj_type = 'Gravnet'

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        # Collect checked items into adjustment object
        if self.label_deltas_update_required.set is True:
            reply = QtWidgets.QMessageBox.question(self, 'Message',
                                                   'The Relative-gravity differences table on the Network Adjustment ' +
                                                   'is out of date. Proceed anyway?',
                                                   QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)

            if reply == QtWidgets.QMessageBox.No:
                return

        if how_many == 'all':
            for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                obstreesurvey = self.obsTreeModel.invisibleRootItem().child(i)
                obstreesurvey.run_inversion(adj_type)
        elif how_many == 'current':
            obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            obstreesurvey.run_inversion(adj_type)
        # Tools available if there is more than one survey
        if self.obsTreeModel.invisibleRootItem().rowCount() > 1:
            self.menus.set_state(MENU_STATE.MORE_THAN_ONE_SURVEY)

        self.menus.mnAdjPlotCompareDatum.setEnabled(True)
        self.statusBar().showMessage("Network adjustment complete")
        self.update_adjust_tables()
        QtWidgets.QApplication.restoreOverrideCursor()

        self.adjust_update_not_required()

    def show_gravity_change_table(self):
        GravityChangeTable(self, table_type='simple')

    def plot_network_graph_circular(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        coords = self.obsTreeModel.station_coords
        plot_network_graph(survey, coords, shape='circular')

    def plot_network_graph_map(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        coords = self.obsTreeModel.station_coords
        plot_network_graph(survey, coords, shape='map')

    def plot_datum_vs_adjusted(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        plot_compare_datum_to_adjusted(survey)

    def plot_datum_comparison_timeseries(self):
        FigureDatumComparisonTimeSeries(self.obsTreeModel)

    def plot_histogram(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        p = plot_adjust_residual_histogram(survey)
        return p

    def set_adj_sd(self, survey, ao):
        """
        Update delta table based on parameters in net. adj. options
        :param survey: For which to set delta-g sd
        :param ao: AdjustmentOptions object
        """
        for i in range(survey.delta_model.rowCount()):
            ind = survey.delta_model.createIndex(i, 7)  # Column 7: minimum standard deviation
            delta = survey.delta_model.data(ind, role=QtCore.Qt.UserRole)
            additive = 0
            factor = 1
            if ao.use_sigma_add:
                additive = ao.sigma_add
            if ao.use_sigma_factor:
                factor = ao.sigma_factor
            if ao.use_sigma_min:
                sigma = max(ao.sigma_min, delta.sd * factor + additive)
            else:
                sigma = delta.sd * factor + additive
            survey.delta_model.setData(ind, sigma, role=QtCore.Qt.EditRole)
        self.update_adjust_tables()

    def menu_import_abs_g_simple(self):
        """
        Slot for mnAdjImportAbsSimple
        Returns
        -------

        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None,
                                                         'Open file (3 columns, space delimited, station-g-std. dev.)',
                                                         self.path_data)
        logging.info('Importing absolute gravity data from {}'.format(fname))
        try:
            datums = import_abs_g_simple(fname)
        except IndexError:
            self.msg = show_message(
                'Error reading absolute gravity file. Is it three columns (station, g, std. dev.), ' +
                'space delimited', 'File read error')
        for datum in datums:
            self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.insertRows(datum, 0)
            logging.info('Datum imported: {}'.format(datum.__str__()))
        self.set_window_title_asterisk()


    def menu_import_abs_g_complete(self):
        """
        Slot for mnAdjImportAbsFull

        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open A10_parse.py output file',
                                                         self.path_data)
        logging.info('Importing absolute gravity data from {}'.format(fname))
        datums = import_abs_g_complete(fname)
        for datum in datums:
            self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.insertRows(datum, 0)
            logging.info('Datum imported: {}'.format(datum.__str__()))
        self.set_window_title_asterisk()

    def dialog_import_abs_g_direct(self):
        """
        Opens a PyQt dialog to select a directory with .project.txt files.
        """
        if self.obsTreeModel.rowCount() == 0:
            self.msg = show_message('Please load a survey before loading absolute-gravity data.',
                         'Import error')
            return
        if hasattr(self, 'abs_data_path'):
            selectabsg = SelectAbsg(self.path_absolute_data)
        else:
            selectabsg = SelectAbsg(self.path_data)
        if selectabsg.exec_():
            nds = selectabsg.new_datums
            self.path_absolute_data = selectabsg.path
        for nd in nds:
            self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.insertRows(nd, 0)
        self.set_window_title_asterisk()

    def write_metadata_text(self):
        """
        Exports processing summary for metadata file.
        """
        export_metadata(self.obsTreeModel, self.path_data)

    def write_summary_text(self):
        """
        Write complete summary of data and adjustment, with the intent that the processing can be re-created later
        """
        export_summary(self.obsTreeModel, self.path_data)

    def write_tabular_data(self):
        """
        Write data to file
        """
        export_data(self.obsTreeModel, self.path_data)

    def dialog_add_datum(self):
        """
        Opens PyQt dialog to select an existing station to assign a datum value
        """
        stations = []
        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            obstreesurvey = self.obsTreeModel.invisibleRootItem().child(i)
            for ii in range(obstreesurvey.delta_model.rowCount()):
                ind = obstreesurvey.delta_model.createIndex(ii, 0)
                delta = obstreesurvey.delta_model.data(ind, QtCore.Qt.UserRole)
                stations.append(delta.sta1)
                stations.append(delta.sta2)
        station_list = list(set(stations))
        station_list.sort()
        station = AddDatumFromList.add_datum(station_list)
        if station:
            d = Datum(str(station))
            self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.insertRows(d, 0)
            logging.info('Datum station added: {}'.format(station))
            self.set_window_title_asterisk()

    def dialog_adjustment_properties(self):
        """
        Opens PyQt dialog to set adjustment options
        """
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        adjust_options = AdjustOptions(survey.__str__(), survey.adjustment.adjustmentoptions, parent=self)
        if adjust_options.exec_():
            if adjust_options.surveys_to_update == 'single':
                # Not sure why the deepcopy is necessary. Without it, all of the survey.adjustmentoptions
                # reference the same object.
                ao = copy.deepcopy(adjust_options.ao)
                survey.adjustment.adjustmentoptions = ao
                self.set_adj_sd(survey, adjust_options.ao)
            elif adjust_options.surveys_to_update == 'all':
                for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                    ao = copy.deepcopy(adjust_options.ao)
                    survey = self.obsTreeModel.invisibleRootItem().child(i)
                    survey.adjustment.adjustmentoptions = ao
                    self.set_adj_sd(survey, adjust_options.ao)
            self.set_window_title_asterisk()

    def dialog_tide_correction(self):
        """
        Opens PyQt dialog to specify correction type
        """
        tide_correction_dialog = TideCorrectionDialog()
        tide_correction_dialog.msg.exec_()
        correction_type = tide_correction_dialog.correction_type
        if correction_type == 'Cancel':
            return
        elif correction_type == 'Meter-supplied':
            tide_correction_meter(self)
        elif correction_type == 'Agnew':
            lat, lon, elev = [], [], []
            # Get mean coordinates as default position
            for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                survey = self.obsTreeModel.invisibleRootItem().child(i)
                for ii in range(survey.rowCount()):
                    loop = survey.child(ii)
                    for iii in range(loop.rowCount()):
                        station = loop.child(iii)
                        lat += station.lat
                        lon += station.long
                        elev += station.elev
            try:
                lat.remove(0.0)
            except ValueError:
                pass
            try:
                lon.remove(0.0)
            except ValueError:
                pass
            try:
                elev.remove(0.0)
            except ValueError:
                pass

            lat = np.mean(list(lat))
            lon = np.mean(list(lon))
            elev = np.mean(list(elev))

            tc = TideCoordinatesDialog(lat, lon, elev)
            if tc.exec_():
                tide_correction_agnew(self, float(tc.lat.text()),
                                      float(tc.lon.text()),
                                      float(tc.elev.text()))
            self.deltas_update_required()
            self.adjust_update_required()
        self.plot_samples()

    def dialog_station_coordinates(self):
        """
        Shows station coordinates dialog.
        :return:
        """
        coordinates_dialog = CoordinatesTable(self.obsTreeModel.station_coords)
        test = coordinates_dialog.exec_()
        if test == 1:
            self.obsTreeModel.station_coords = coordinates_dialog.coords()

    def load_station_coordinates(self):
        """
        Load station coordinates from file
        :return:
        """
        # TODO: load station coordinates dialog
        return

    # def close_windows(self):
    #     """
    #     Function for closing all windows
    #     """
    #     if self.windowTitle()[-1] == '*':
    #         self.clo
    #     self.close()

    def closeEvent(self, event):
        if self.windowTitle()[-1] == '*':
            quit_msg = "The workspace isn't saved. Are you sure you want to exit the program?"
            reply = QtWidgets.QMessageBox.question(self, 'Message',
                                               quit_msg, QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)

            if reply == QtWidgets.QMessageBox.Yes:
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()

    @staticmethod
    def show_help():
        """
        Shows compiled help file created using Dr. Explain
        """
        webbrowser.open('file://' + os.path.realpath('./docs/index.htm'))

    def check_for_updates(self, show_uptodate_msg, parent=None):
        """
        Check if the usgs_root repo is at the same commit as this installation
        Parameters
        ----------
        e : qt event
        parent: Splash screen. Using this as the QMessageBox parent shows the MB centered over the splash screen.
        show_uptodate_msg : bool
           Whether to display a msg if no updates found
        Returns
        -------
        Booblean, whether or not to start GSadjust (True  yes)
        """
        try:
            gitpath = os.path.dirname(self.path_install) + "\\gsadjust-env\\Lib\\mingw64\\bin"
            os.environ["PATH"] += os.pathsep + gitpath
            from git import Repo
            # install_dir = utils.get_install_dname('pymdwizard')
            logging.info('Checking for updates')
            repo = Repo(self.path_install)
            fetch = [r for r in repo.remotes if r.name == 'origin'][0].fetch()
            master = [f for f in fetch if f.name == 'origin/master'][0]
            for f in fetch:
                logging.info('Git fetched: {}'.format(f))

            if repo.head.commit != master.commit:
                msg = "An update is available for GSadjust.\n"
                msg += "Would you like to install now?"

                confirm = QtWidgets.QMessageBox.question(parent, "Updates Available", msg,
                                                         QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
                if confirm == QtWidgets.QMessageBox.Yes:
                    return self.update_from_github()
            elif show_uptodate_msg:
                logging.info('Git checked, GSadjust is up to date.')
                msg = "GSadjust is up to date."
                QtWidgets.QMessageBox.information(self, "No Update Needed", msg)
                return True
            return True

        except BaseException as e:
            logging.info('Git update failed: {}'.format(e))
            if show_uptodate_msg:
                msg = 'Problem Encountered Updating from GitHub\n\nError Message:\n'
                msg += str(e)
                QtWidgets.QMessageBox.information(self, "Update results", msg)
            return True  # Update didn't work, start GSadjust anyway

    def update_from_github(self):
        """
        Merge the latest version of the Wizard into the local repo
        Returns
        -------
        None
        """

        try:
            from git import Repo
            # install_dir = utils.get_install_dname('pymdwizard')
            repo = Repo(self.path_install, )
            fetch = [r for r in repo.remotes if r.name == 'origin'][0].fetch()
            master = [f for f in fetch if f.name == 'origin/master'][0]
            repo.git.reset('--hard')
            repo.git.merge(master.name)
            logging.info('Git update successful')
            msg = 'Updated successfully downloaded from GitHub. Please\n' \
                  'restart GSadjust.'
            QtWidgets.QMessageBox.information(self, "Update results", msg)
            return False  # Don't launch GSadjust, need to restart to install updates

        except BaseException as e:
            logging.info('Git update failed: {}'.format(e))
            msg = 'Problem Encountered Updating from GitHub\n\n' \
                  'Please upgrade to the latest release by reinstalling the ' \
                  'application from GitHub ' \
                  '\n(https://github.com/jkennedy-usgs/sgp-gsadjust/releases)\n\n' \
                  'Error Message:\n'
            msg += str(e)
            QtWidgets.QMessageBox.information(self, "Update results", msg)
            return True  # Update didn't work, launch anyway


class BoldDelegate(QtWidgets.QStyledItemDelegate):
    """
    Makes selected item in tree view bold.
    See     http://www.qtcentre.org/threads/61716-Set-the-color-of-a-row-in-a-qtreeview
    """

    def paint(self, painter, option, index):
        m = index.model().itemFromIndex(index)
        # decide here if item should be bold and set font weight to bold if needed
        if not hasattr(m, 'fontweight'):
            option.font.setWeight(QtGui.QFont.Normal)
            m.cellcolor = QtCore.Qt.white
        else:
            option.font.setWeight(m.fontweight)
        painter.fillRect(option.rect, m.cellcolor)
        QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)


class ProgressBar(QtWidgets.QWidget):
    """
    define progress bar
    """

    def __init__(self, total=20, textmess='Progress'):
        super(ProgressBar, self).__init__()
        self.progressbar = QtWidgets.QProgressBar()
        self.progressbar.setMinimum(1)
        self.progressbar.setMaximum(total)
        main_layout = QtWidgets.QGridLayout()
        main_layout.addWidget(self.progressbar, 0, 1)
        self.setLayout(main_layout)
        self.setWindowTitle(textmess)


def handle_exception(exc_type, exc_value, exc_traceback):
    """ 
    Sends exceptions to log file
    """
    # KeyboardInterrupt is a special case, don't raise the error dialog when it occurs.
    if issubclass(exc_type, KeyboardInterrupt):
        if QtWidgets.qApp:
            QtWidgets.qApp.quit()
        return

    filename, line, dummy, dummy = traceback.extract_tb(exc_traceback).pop()
    filename = os.path.basename(filename)
    error = "{}: {}".format(exc_type.__name__, exc_value)
    logging.error(error + " at line {:d} of file {}".format(line, filename))


def main():
    app = QtWidgets.QApplication(sys.argv)
    # GSadjust starts in different directories on Mac and Windows
    if sys.platform == 'darwin':
        os.chdir('../')
    else:
        os.chdir('../sgp-gsadjust')

    # start log file
    fn = 'GSadjustLog_' + time.strftime("%Y%m%d-%H%M") + '.txt'
    # Should probably change this to try a different location for the log file.
    try:
        logging.basicConfig(filename=fn, format='%(levelname)s:%(message)s', level=logging.INFO)
    except PermissionError:
        show_message('Please install GSadjust somewhere where admin rights are not required.', 'GSadjust error')
    sys.excepthook = handle_exception

    splash_pix = QtGui.QPixmap('./gsadjust/resources/Splash.png')
    splash = QtWidgets.QSplashScreen(splash_pix, QtCore.Qt.WindowStaysOnTopHint)
    splash.setMask(splash_pix.mask())
    splash.show()
    ex = MainProg(splash=splash)
    app.processEvents()
    splash.finish(ex)

    if ex.check_for_updates(False, parent=splash):
        app.setWindowIcon(QtGui.QIcon('./gsadjust/resources/g.png'))
        ex.showMaximized()
        app.processEvents()

        app.exec_()
    else:
        ex.close()

# Import here to avoid circular import error
from gui_objects import show_message, SelectAbsg, AdjustOptions, LoopOptions

if __name__ == '__main__':
    main()
