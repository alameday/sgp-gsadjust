#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
GSadjust, for the interactive network adjustment of relative-gravity networks
=============================================================================

Version 1.0
April 2018

Jeff Kennedy, USGS
jkennedy@usgs.gov

GSadjust is a Python 3.5/PyQt5 program that provides a graphical user interface for post-processing combined
relative- and absolute- gravity surveys.

GSadjust was originally based on PyGrav:
Hector, B. and Hinderer, J.: pyGrav, a Python-based program for handling and
processing relative gravity data, Computers & Geosciences, doi:10.1016/j.cageo.2016.03.010, 2016.

GSadjust is distributed with the network adjustment software Gravnet (Windows executable)
(Hwang, C., C. Wang and L. Lee. 2002. Adjustment of relative gravity measurements
using weighted and datum-free constraints. Computers & Geosciences 28 1005â€“1015)

This software is preliminary, provisional, and is subject to revision. It is being provided to meet the need for
timely best science. The software has not received final approval by the U.S. Geological Survey (USGS). No warranty,
expressed or implied, is made by the USGS or the U.S. Government as to the functionality of the software and related
material nor shall the fact of release constitute any such warranty. The software is provided on the condition that
neither the USGS nor the U.S. Government shall be held liable for any damages resulting from the authorized or
unauthorized use of the software.

GSadjust file organization is:

GSadjust.py:
  major PyQt elements (tabs, menus)
tab_data.py
  PyQt elements on the data tab
tab_drift.py
  PyQt elements on the drift tab
tab_network.py
  PyQt elements on the network adjustment tab
menus.py
  Creates PyQt menus
gui_objects.py:
  minor PyQt elements (popup windows/dialogs)
data_objects.py:
  Non Py-Qt data objects (Deltas, Datums, etc.)
  Network adjustment code
pyqt_models.py:
  PyQt-specific data models: ObsTreeSurvey, ObsTreeLoop, etc.
tide_correction.py:
  Earth tide and ocean loading code
synthetic_tides.py:
  Tide model coefficients
a10.py:
  Parses *.project.txt files generated by 'g' software (A-10 and FG-5 absolute-gravity meters)

PyQt models follow the PyQt CamelCase naming convention. The other methods/functions in GSadjust use PEP-8
lowercase_underscore convention.

The general data structure of the program is stored as PyQt objects inherited from QStandardItem:

+------------+
| Campaign   |
++-----------+
 |  +---------------------------+
 +--+ Surveys (ObsTreeSurvey)   |
    ++--------------------------+
     |  +-------------+
     +--+ Adjustment  |
     |  +-------------+
     |  +-------------+
     +--+ datum_model |
     |  +-------------+
     |  +-------------+
     +--+ delta_model |
     |  +-------------+
     |  +---------------+
     +--+ results_model |
     |  +---------------+
     |  +----------------------+
     |--+ Loops (ObsTreeLoop)  |
        ++---------------------+
         |  +--------------+
         +--+ delta_model  |
            ++-------------+
         |  +-------------+
         +--+ tare_model  |
            ++------------+
         |  +----------------------------+
         +--+ Stations (ObsTreeStation)  |
            ++---------------------------+
             |  +--------------------+
             +--+ g, lat, long, etc. |
                +--------------------+

The Adjustment object in each ObsTreeSurvey holds the network adjustment input, output, and options. There is one
Adjustment per Survey.

The datum_model, delta_model, results_model, and tare_model are PyQt models. The gui is update with the respective model when a new
Survey or Loop is selected (by double-clicking in the tree view). There is one of each table per Survey.

"""

# Standard library modules
import sys
import os
import logging
import traceback
import copy
import datetime as dt
import time
import csv
import webbrowser

# Modules that must be installed
import numpy as np
from PyQt5 import QtGui, QtCore, QtWidgets
import matplotlib.pyplot as plt
import ctypes
# For network graphs
import networkx as nx  # networkx 1.9

from data_objects import Datum, Tare, AdjustmentResults, ChannelList
from pyqt_models import BurrisTableModel, ScintrexTableModel
from pyqt_models import ObsTreeModel
from pyqt_models import ObsTreeStation, ObsTreeLoop, ObsTreeSurvey
from gui_objects import GravityChangeTable, TideCorrectionDialog, TideCoordinatesDialog, ApplyTimeCorrection
from gui_objects import VerticalGradientDialog, AddTareDialog, MeterType, LoopTimeThresholdDialog, Overwrite

from tab_network import TabAdjust
from tab_drift import TabDrift
from tab_data import TabData
from menus import menus
from tide_correction import tide_correction_agnew

"""
To install conda env:
conda create -n pyg35 python=3.5 numpy scipy=0.19 pyqt=5 networkx matplotlib pywin32 

(scipy 1.0 causes a bug with pyinstaller)

installer:
conda install pyinstaller 
pip install pefile pypiwin32

Run in a conda env named pyg35
$>activate pyg
$>pyinstaller --onefile GSadjust.spec

The next section manually loads mkl_mc.dll and mkl_def.dll, see
https://github.com/pyinstaller/pyinstaller/wiki/Recipe-Win-Load-External-DLL
"""

# Override dll search path.
ctypes.windll.kernel32.SetDllDirectoryW(':\Shared\current\python\Miniconda3\envs\pyg35\Library\bin')
# Init code to load external dll
ctypes.CDLL('mkl_avx2.dll')
ctypes.CDLL('mkl_def.dll')
# Restore dll search path.
ctypes.windll.kernel32.SetDllDirectoryW(None)


class MainProg(QtWidgets.QMainWindow):
    """
    GSadjust main routine
    """
    data_path = r'../test_data'
    drift_lookup = {'none': 0, 'netadj': 1, 'roman': 2, 'continuous': 3}
    t_threshold = 0  # Time between surveys for automatic survey detection
    obsTreeModel = ObsTreeModel()
    prevLoopItem = None
    prevSurvItem = None
    vertical_gradient_interval = 64.2
    workspace_loaded = False
    dpi = 60  # resolution for data plots
    output_root_dir = None
    all_survey_data = None
    currentSurveyIndex = None
    currentLoopIndex = None
    currentStationIndex = None
    currentLoopSurveyIndex = None
    currentStationLoopIndex = None
    currentStationSurveyIndex = None
    treeviewpopMenu = None
    status_text = None
    menus, selmodel = None, None
    tab_data, tab_drift, tab_adjust = None, None, None
    station_model, station_coords = None, None

    def __init__(self):
        super(MainProg, self).__init__()
        logging.info(
            'GSadjust session from computer ' + os.environ["COMPUTERNAME"] + ', ' + time.strftime('%H:%M %Y-%m-%d'))

        self.menus = menus(self)
        self.setGeometry(50, 50, 350, 300)
        self.setWindowTitle('GSadjust')

        # tab_....s are populated with GUI elements in the tab_...() functions
        self.tab_data = TabData(self)
        self.tab_drift = TabDrift(self)
        self.tab_adjust = TabAdjust()
        self.tab_widget = QtWidgets.QTabWidget()

        self.tab_widget = QtWidgets.QTabWidget()
        self.tab_widget.addTab(self.tab_data, 'Data')
        self.tab_widget.addTab(self.tab_drift, 'Drift')
        self.tab_widget.addTab(self.tab_adjust, 'Network Adjustment')
        self.tab_widget.setStyleSheet("QTabBar::tab { font-size: 12pt; height: 40px; width: 250px }")
        self.tab_widget.currentChanged.connect(self.tab_changed)

        self.treeview_widget = QtWidgets.QWidget()
        self.treeview_box = QtWidgets.QVBoxLayout()
        self.treeview_box.addItem(QtWidgets.QSpacerItem(200, 42))
        self.data_treeview = QtWidgets.QTreeView()

        self.treeview_box.addWidget(self.data_treeview)
        self.treeview_widget.setLayout(self.treeview_box)

        self.main_window_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        self.main_window_splitter.addWidget(self.treeview_widget)
        self.main_window_splitter.addWidget(self.tab_widget)
        self.setCentralWidget(self.main_window_splitter)

        # Setup statusbar icons
        self.update_deltas_text = QtWidgets.QLabel("Update delta table:", self)
        self.update_adjust_text = QtWidgets.QLabel("    Update adjustment:", self)
        self.update_not_needed_icon = QtGui.QPixmap('ico3.png')
        self.update_adjust_icon = QtGui.QPixmap('ico2.png')
        self.update_deltas_icon = QtGui.QPixmap('ico1.png')
        self.adjust_update_required_label = QtWidgets.QLabel()
        self.deltas_update_required_label = QtWidgets.QLabel()

        self.statusBar().addPermanentWidget(self.update_deltas_text)
        self.statusBar().addPermanentWidget(self.deltas_update_required_label)
        self.statusBar().addPermanentWidget(self.update_adjust_text)
        self.statusBar().addPermanentWidget(self.adjust_update_required_label)

        self.adjust_update_required()
        self.deltas_update_required()

        # Right-click tree view context menu
        self.menus.mnDeleteSurvey = self.menus.create_action('Delete survey', slot=self.delete_selected)
        self.menus.mnDeleteLoop = self.menus.create_action('Delete loop', slot=self.delete_selected)
        self.menus.mnStationDelete = self.menus.create_action('Delete station(s)', slot=self.delete_station)
        self.menus.mnStationDuplicate = self.menus.create_action('Duplicate station', slot=self.duplicate_station)
        self.menus.mnDataNewLoop = self.menus.create_action('Move station(s) to new loop', slot=self.new_loop)

        # self.resize(600,800)
        self.showNormal()
        self.setWindowState(QtCore.Qt.WindowMaximized)

    def init_gui(self):
        """
        Called after loading a data file.
        """
        # Left panel: tree with data hierarchy (surveys, loops, stations)
        self.obsTreeModel.setHorizontalHeaderLabels(['Name', 'Date', 'g (microGal)'])

        # Enable menus
        self.menus.mnFileAppendLoop.setEnabled(True)
        self.menus.mnFileAppendSurvey.setEnabled(True)
        self.menus.mnFileAppendWorkspace.setEnabled(True)
        self.menus.mnFileSaveWorkspace.setEnabled(True)
        self.menus.mnFileSaveWorkspace.setEnabled(True)
        self.menus.mnEditTideCorrection.setEnabled(True)
        self.menus.mnEditCorrectRecordedTimeAction.setEnabled(True)
        self.menus.mnAdjUpdateDeltas.setEnabled(True)
        self.menus.mnAdjUpdateDeltasCurrentSurvey.setEnabled(True)
        self.menus.mnAdjUpdateDeltasCurrentLoop.setEnabled(True)
        self.menus.mnAdjClearDeltaTable.setEnabled(True)
        self.menus.mnAdjClearDatumTable.setEnabled(True)
        self.menus.mnAdjUpdateDeltas.setEnabled(True)
        self.menus.mnAdjUpdateDeltasCurrentSurvey.setEnabled(True)

        # Resize, expand tree view
        self.data_treeview.setModel(self.obsTreeModel)
        self.obsTreeModel.dataChanged.connect(self.on_obs_checked_change)
        self.obsTreeModel.refreshView.connect(self.refresh_tables)
        self.selmodel = self.data_treeview.selectionModel()
        self.selmodel.selectionChanged.connect(self.on_obs_tree_change)
        # self.data_treeview.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)

        self.data_treeview.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.data_treeview.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.data_treeview.customContextMenuRequested.connect(self.treeview_context_menu)
        self.data_treeview.setItemDelegate(BoldDelegate(self))
        self.data_treeview.doubleClicked.connect(self.activate_survey_or_loop)
        self.data_treeview.setObjectName('data')
        self.data_treeview.setEditTriggers(QtWidgets.QTreeView.EditKeyPressed)
        self.data_treeview.setExpandsOnDoubleClick(False)
        self.data_treeview.expandAll()
        self.data_treeview.resizeColumnToContents(0)
        self.data_treeview.resizeColumnToContents(1)
        self.data_treeview.resizeColumnToContents(2)

        # Highlight first tree-view item
        obstreesurvey = self.obsTreeModel.itemFromIndex(self.obsTreeModel.index(0, 0))
        obstreeloop = obstreesurvey.child(0)
        station = obstreeloop.child(0)

        # Set current keys
        self.currentSurveyIndex = obstreesurvey.index()
        self.currentLoopIndex = obstreeloop.index()
        self.currentLoopSurveyIndex = obstreesurvey.index()
        self.currentStationLoopIndex = obstreeloop.index()
        self.currentStationSurveyIndex = obstreesurvey.index()
        self.currentStationIndex = station.index()

        # Activate first tree view item
        self.activate_survey_or_loop(self.currentLoopIndex)
        self.activate_survey_or_loop(self.currentSurveyIndex)

        # Set data plot
        self.prep_station_plot()
        # self.selmodel.select(station.index(), QtCore.QItemSelectionModel.SelectCurrent)
        self.data_treeview.setFocus()

    def adjust_update_required(self):
        """
        Updates status bar icon
        """
        self.adjust_update_required_label.set = True
        self.adjust_update_required_label.setPixmap(self.update_adjust_icon)
        self.adjust_update_required_label.setToolTip('Update network adjustment')

    def adjust_update_not_required(self):
        """
        Updates status bar icon
        """
        self.adjust_update_required_label.set = False
        self.adjust_update_required_label.setPixmap(self.update_not_needed_icon)
        self.adjust_update_required_label.setToolTip('Network adjustment is up to date')

    def deltas_update_required(self):
        """
        Updates status bar icon
        """
        self.deltas_update_required_label.set = True
        self.deltas_update_required_label.setPixmap(self.update_deltas_icon)
        self.deltas_update_required_label.setToolTip('Update delta table')

    def deltas_update_not_required(self):
        """
        Updates status bar icon
        """
        self.deltas_update_required_label.set = False
        self.deltas_update_required_label.setPixmap(self.update_not_needed_icon)
        self.deltas_update_required_label.setToolTip('Delta table is up to date')

    def tab_changed(self, new_idx):
        """
        Updates tab plots/tables as needed. These typically aren't updated unless they're visible.
        :param new_idx: Index of newly-selected tab.
        """
        if new_idx == 0:
            self.prep_station_plot()
        if new_idx == 1:
            self.update_drift_tables_and_plots()

    def prep_station_plot(self):
        """
        Get station to plot, update station table model if necessary.
        """
        # Center panel: table (station values)
        obstreestation = self.obsTreeModel.itemFromIndex(self.currentStationIndex)
        obstreeloop = obstreestation.parent()
        station = obstreestation
        if obstreeloop.meter_type == 'Scintrex' or obstreeloop.meter_type == 'CG6':
            self.station_model = ScintrexTableModel(station)
        elif obstreeloop.meter_type == 'Burris':
            self.station_model = BurrisTableModel(station)
        self.station_model.dataChanged.connect(self.prep_station_plot)
        self.station_model.updateCoordinates.connect(self.populate_coordinates)
        self.station_model.signal_adjust_update_required.connect(self.adjust_update_required)
        self.tab_data.data_view.setModel(self.station_model)
        self.obsTreeModel.dataChanged.emit(QtCore.QModelIndex(), QtCore.QModelIndex())
        self.tab_data.update_station_plot(station, obstreeloop.meter_type)

    ###########################################################################
    # Load/Open/Save routines
    ###########################################################################
    def open_raw_data(self, meter_type):
        """
        - Display a file opening window
        - Populate obsTreeModel
        """
        # open file
        show_overwrite_dialog = False
        overwrite = False
        append_loop = False
        if 'loop' in meter_type:
            append_loop = True
        if 'choose' in meter_type:
            meter_type_dialog = MeterType()
            if meter_type_dialog.msg.exec_():
                meter_type = meter_type_dialog.meter_type
        elif self.obsTreeModel.invisibleRootItem().rowCount() > 0:
            show_overwrite_dialog = True

        if show_overwrite_dialog:
            overwrite_tree_dialog = Overwrite()
            if overwrite_tree_dialog.msg.exec_():
                overwrite = overwrite_tree_dialog.overwrite

        if overwrite:
            self.workspace_clear()

        fname, _ = QtWidgets.QFileDialog.getOpenFileName(caption='Open file', directory=self.data_path)
        self.output_root_dir = os.path.dirname(fname)
        if fname:
            logging.info('Loading data file: %s', fname)
            self.data_path = os.path.dirname(str(fname))
            # populate a Campaign object
            try:
                self.all_survey_data = self.read_raw_data_file(fname, meter_type)
                if append_loop:
                    obstreesurvey = self.obsTreeModel.itemFromIndex(self.currentSurveyIndex)
                    obstreesurvey.populate(self.all_survey_data, name=str(obstreesurvey.loop_count))
                else:
                    obstreesurvey = ObsTreeSurvey(str(self.all_survey_data.t[0].date()))
                    obstreesurvey.populate(self.all_survey_data)
                    self.obsTreeModel.appendRow([obstreesurvey, QtGui.QStandardItem('a'), QtGui.QStandardItem('a')])
            except Exception as e:
                logging.exception(e, exc_info=True)
                show_message('Failed to read raw data file', 'File error')
                return
            self.init_gui()
            self.prep_station_plot()
            if meter_type == 'Burris' or meter_type == 'CG6':
                self.populate_coordinates()
            self.workspace_loaded = True
            QtWidgets.QApplication.restoreOverrideCursor()
            QtWidgets.QApplication.processEvents()
        else:
            return False

    @staticmethod
    def read_raw_data_file(filename, meter_type):
        """
        Read raw relative-gravity text file in the format exported from meter (Scintrex or Burris). Data are returned to
        the calling function.
        :param filename: Full path to import file
        :param meter_type: 'Burris' or 'Scintrex'
        :return all_survey_data: ChannelList object with all survey data
        """
        i = 0
        meter, oper = None, None
        try:
            all_survey_data = ChannelList()
            fh = open(filename, 'r')
            logging.info("number of lines: {:d}".format(len([1 for line in open(filename, 'r')])))
            all_survey_data.meter_type = meter_type
            if meter_type == 'Scintrex':
                for line in fh:
                    i += 1
                    # Clean line
                    line = line.strip()
                    # Skip blank and comment lines
                    if (not line) or (line[0] == 'L'):
                        continue
                    if line[0] == '/':
                        vals_temp = line.split()
                        if len(vals_temp) > 1:
                            if vals_temp[1] == 'Instrument':
                                meter = vals_temp[-1]
                            if vals_temp[1] == 'Operator:':
                                oper = vals_temp[-1]
                        continue

                    # parse string line first with respect to '/' caracters (used in the date format),
                    # then with ':' (used for the time display), eventually with the classic ' '
                    vals_temp1 = line.split('/')
                    vals_temp2 = vals_temp1[0].split(':')
                    vals_temp3 = vals_temp2[0].split()
                    vals_temp4 = vals_temp2[2].split()

                    # fill object properties:
                    all_survey_data.line.append(float(vals_temp3[0]))
                    s = vals_temp3[1].replace('.0000000', '')
                    all_survey_data.station.append(s)
                    all_survey_data.elev.append(float(vals_temp3[2]))
                    all_survey_data.raw_grav.append(float(vals_temp3[3]) * 1000.)  # convert to microGal
                    all_survey_data.tare.append(0)
                    all_survey_data.sd.append(float(vals_temp3[4]) * 1000.)
                    all_survey_data.tiltx.append(float(vals_temp3[5]))
                    all_survey_data.tilty.append(float(vals_temp3[6]))
                    all_survey_data.temp.append(float(vals_temp3[7]))
                    all_survey_data.etc.append(float(vals_temp3[8]) * 1000.)
                    all_survey_data.meter_etc.append(float(vals_temp3[8]) * 1000.)
                    all_survey_data.dur.append(int(vals_temp3[9]))
                    all_survey_data.rej.append(int(vals_temp3[10]))
                    all_survey_data.t.append(dt.datetime(int(vals_temp4[3]),
                                                         int(vals_temp1[1]),
                                                         int(vals_temp1[2]),
                                                         int(vals_temp3[11]),
                                                         int(vals_temp2[1]),
                                                         int(vals_temp4[0])))
                    if meter:
                        all_survey_data.meter.append(meter)
                    else:
                        all_survey_data.meter.append('-999')
                    if oper:
                        all_survey_data.oper.append(oper)
                    else:
                        all_survey_data.oper.append('-999')
                    all_survey_data.keepdata.append(1)
                all_survey_data.meter_type = meter_type

            elif meter_type == 'Burris':
                for line in fh:
                    i += 1
                    line = line.strip()
                    vals_temp = line.split()
                    # Numbers are columns in the imported file
                    c_station, c_oper, c_meter, c_date, c_time = 0, 1, 2, 3, 4
                    c_dial, c_feedback, c_tide, c_tilt = 6, 7, 8, 9
                    c_grav, c_elev, c_lat, c_long = 5, 13, 14, 15
                    if len(vals_temp) == 15:  # no meter operator specified
                        c_dial -= 1
                        c_feedback -= 1
                        c_tide -= 1
                        c_tilt -= 1
                        c_meter -= 1
                        c_date -= 1
                        c_time -= 1
                        c_grav -= 1
                        c_elev -= 1
                        c_lat -= 1
                        c_long -= 1
                        all_survey_data.oper.append('None')
                    else:
                        all_survey_data.oper.append(vals_temp[c_oper])

                    date_temp = vals_temp[c_date].split('/')
                    time_temp = vals_temp[c_time].split(':')

                    # fill object properties:
                    all_survey_data.line.append(0.)
                    all_survey_data.station.append(vals_temp[0])
                    all_survey_data.elev.append(float(vals_temp[c_elev]))
                    all_survey_data.lat.append(float(vals_temp[c_lat]))
                    all_survey_data.long.append(float(vals_temp[c_long]))
                    # remove Earth tide correction; it's added in using the @grav property
                    all_survey_data.raw_grav.append(float(vals_temp[c_grav]) * 1000. -
                                                float(vals_temp[c_tide]) * 1000.)
                    all_survey_data.tare.append(0)
                    all_survey_data.etc.append(float(vals_temp[c_tide]) * 1000.)
                    all_survey_data.meter_etc.append(float(vals_temp[c_tide]) * 1000.)
                    all_survey_data.dial.append(float(vals_temp[c_dial]))
                    all_survey_data.feedback.append(float(vals_temp[c_feedback]))
                    all_survey_data.sd.append(-999)  # Burris doesn't ouput SD, tiltx, tilty
                    all_survey_data.meter.append(vals_temp[c_meter])
                    all_survey_data.tiltx.append(float(vals_temp[c_tilt]) * 1000.)
                    all_survey_data.tilty.append(0.)
                    all_survey_data.temp.append(0.)
                    all_survey_data.dur.append(5)
                    all_survey_data.rej.append(5)
                    all_survey_data.t.append(dt.datetime(int(date_temp[0]),
                                                         int(date_temp[1]),
                                                         int(date_temp[2]),
                                                         int(time_temp[0]),
                                                         int(time_temp[1]),
                                                         int(time_temp[2])))
                    all_survey_data.keepdata.append(1)
                all_survey_data.meter_type = meter_type

            elif meter_type == 'CG6':
                for line in fh:
                    i += 1
                    line = line.strip()
                    vals_temp = line.split()
                    if line[0] == '/':
                        vals_temp = line.split()
                        if len(vals_temp) > 1:
                            if vals_temp[1] == 'Instrument':
                                meter = vals_temp[-1]
                            if vals_temp[1] == 'Operator:':
                                oper = vals_temp[-1]
                        continue
                    # Numbers are columns in the imported file
                    c_station, c_date, c_time, c_sd = 0, 1, 2, 4
                    c_tiltx, c_tilty = 7, 8
                    c_tide, c_tilt, c_temp = 10, 11, 12
                    c_grav, c_elev, c_lat, c_long = 3, 18, 16, 17

                    date_temp = vals_temp[c_date].split('-')
                    time_temp = vals_temp[c_time].split(':')

                    # fill object properties:
                    all_survey_data.line.append(0.)
                    all_survey_data.station.append(vals_temp[0])
                    all_survey_data.elev.append(float(vals_temp[c_elev]))
                    all_survey_data.lat.append(float(vals_temp[c_lat]))
                    all_survey_data.long.append(float(vals_temp[c_long]))
                    all_survey_data.raw_grav.append(float(vals_temp[c_grav]) * 1000.)
                    all_survey_data.tare.append(0)
                    all_survey_data.etc.append(float(vals_temp[c_tide]) * 1000.)
                    all_survey_data.meter_etc.append(float(vals_temp[c_tide]) * 1000.)
                    all_survey_data.sd.append(float(vals_temp[c_sd]) * 1000.)  # Burris doesn't ouput SD, tiltx, tilty
                    all_survey_data.meter.append(meter)
                    all_survey_data.tiltx.append(float(vals_temp[c_tiltx]) * 1000.)
                    all_survey_data.tilty.append(float(vals_temp[c_tilty]) * 1000.)
                    all_survey_data.temp.append(float(vals_temp[c_temp]) * 1000.)
                    all_survey_data.dur.append(5)
                    all_survey_data.rej.append(5)
                    all_survey_data.t.append(dt.datetime(int(date_temp[0]),
                                                         int(date_temp[1]),
                                                         int(date_temp[2]),
                                                         int(time_temp[0]),
                                                         int(time_temp[1]),
                                                         int(time_temp[2])))
                    if meter:
                        all_survey_data.meter.append(meter)
                    else:
                        all_survey_data.meter.append('-999')
                    if oper:
                        all_survey_data.oper.append(oper)
                    else:
                        all_survey_data.oper.append('-999')
                    all_survey_data.keepdata.append(1)

            return all_survey_data

        except IOError:
            show_message('No file : {}'.format(filename), 'File error')
        except ValueError:
            show_message('Read error at line {:d} : check raw data file'.format(i), 'File error')
        except IndexError:
            show_message('pb at line {:d} : check raw data file: possibly last line?'.format(i), 'File error')

    def divide_survey(self):
        """
        Called from "Divide loop..." menu command. Shows a dialog to specify a time interval, then scans the current
        loop and divides station occupations separated by the time interval (or greater) into a loop. Useful primarily
        when several day's data is in a single file.
        """

        # Prompt user to select time threshold
        loopdialog = LoopTimeThresholdDialog()
        loop_thresh = 0
        if loopdialog.exec_():
            loop_thresh = loopdialog.dt_edit.dateTime()
            # Convert to days. Subtract one from the date because the default is 1 (i.e., if the time set in the
            # loop dialog is 8:00, loop thresh is a Qdatetime equal to (2000,1,1,8,0).
            loop_thresh = int(loop_thresh.toString("H")) / 24 + int(loop_thresh.toString("d")) - 1

        obstreeloop = self.obsTreeModel.itemFromIndex(self.currentLoopIndex)
        indexes = []

        # Step through loop backward
        for i in range(obstreeloop.rowCount()-1, 1, -1):
            station2 = obstreeloop.child(i)
            station1 = obstreeloop.child(i-1)

            # Check time difference between successive stations
            tdiff = station2.tmean - station1.tmean
            if tdiff > loop_thresh:
                for ii in range(i, obstreeloop.rowCount()):
                    indexes.append(obstreeloop.child(ii).index())
                self.new_loop_from_indexes(indexes)
                indexes = []
        self.obsTreeModel.layoutChanged.emit()

    def update_all_drift_plots(self):
        """
        Updates drift_tab plots and delta_models, even if not in view.
        """
        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            survey = self.obsTreeModel.invisibleRootItem().child(i)
            for ii in range(survey.rowCount()):
                loop = survey.child(ii)
                self.currentLoopIndex = loop.index()
                self.update_drift_tables_and_plots()

    def append_workspace(self):
        """
        Append previously-saved workspace to current workspace.
        """
        self.obsTreeModel.load_workspace(self.data_path)
        self.update_all_drift_plots()
        self.populate_coordinates()
        self.workspace_loaded = True
        QtWidgets.QApplication.restoreOverrideCursor()

    def workspace_clear(self):
        """
        Clears all models and refreshes view.
        """
        self.obsTreeModel = ObsTreeModel()
        self.data_treeview.setModel(None)
        self.data_treeview.update()
        self.tab_data.clear_axes()
        self.tab_data.data_view.setModel(None)
        self.tab_data.data_view.update()
        self.tab_drift.delta_view.setModel(None)
        self.tab_drift.delta_view.update()
        self.tab_drift.dg_samples_view.setModel(None)
        self.tab_drift.dg_samples_view.update()
        self.tab_drift.clear_axes()
        self.tab_adjust.delta_view.setModel(None)
        self.tab_adjust.delta_view.update()
        self.tab_adjust.datum_view.setModel(None)
        self.tab_adjust.datum_view.update()
        self.tab_adjust.__init__()

    def workspace_save(self):
        """
        Saves campaigndata object using pickle.dump()
        """
        if self.deltas_update_required_label.set is True:
            show_message('Workspace cannot be saved while the Relative-gravity differences table on the Network ' +
                         'Adjustment tab is not up to date.', 'Workspace save error')
        else:
            self.obsTreeModel.save_workspace(self.data_path)

    def workspace_load(self):
        """
        Loads campaigndata object from pickle file. Restores PyQt tables to Survey object (PyQt tables can't be
        pickled and are removed in workspace_save).
        """
        self.obsTreeModel.load_workspace(self.data_path)
        self.populate_coordinates()
        firstsurvey = self.obsTreeModel.itemFromIndex(self.obsTreeModel.index(0, 0))
        firstloop = firstsurvey.child(0)
        firststation = firstloop.child(0)
        self.currentSurveyIndex = firstsurvey.index()
        self.currentLoopIndex = firstloop.index()
        self.currentStationIndex = firststation.index()
        self.currentLoopSurveyIndex = firstsurvey.index()
        self.currentStationLoopIndex = firstloop.index()
        self.currentStationSurveyIndex = firstsurvey.index()
        self.populate_coordinates()
        self.menus.mnAdjAdjust.setEnabled(True)
        self.workspace_loaded = True
        self.update_all_drift_plots()
        self.update_adjust_tables()
        self.init_gui()
        self.deltas_update_not_required()
        QtWidgets.QApplication.restoreOverrideCursor()

    def populate_coordinates(self):
        """
        Stores a single set of coordinates for each station with the campaigndata object. The coordinates of the last
        Station in the Survey > Loop > Station heirarchy will be used.
        """
        self.station_coords = dict()
        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            survey = self.obsTreeModel.invisibleRootItem().child(i)
            for ii in range(survey.rowCount()):
                loop = survey.child(ii)
                for iii in range(loop.rowCount()):
                    station = loop.child(iii)
                    self.station_coords[station.station_name] = (station.long[0], station.lat[0])

    ###########################################################################
    # General routines
    ###########################################################################
    def populate_deltamodel(self, populate_type):
        """
        Called from menu item
        :param populate_type: 'all', 'selectedLoop', or 'selectedSurvey'
        """
        table_updated = False
        if populate_type == 'all':
            for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                survey = self.obsTreeModel.invisibleRootItem().child(i)
                table_updated = survey.populate_delta_model()

            # item = self.obsTreeModel.invisibleRootItem()
        elif populate_type == 'selectedsurvey':
            survey = self.obsTreeModel.itemFromIndex(self.currentSurveyIndex)
            table_updated = survey.populate_delta_model()

        elif populate_type == 'selectedloop':
            loop = self.obsTreeModel.itemFromIndex(self.currentLoopIndex)
            survey = loop.parent()
            table_updated = survey.populate_delta_model(loop)

        if table_updated:
            self.deltas_update_not_required()
            self.adjust_update_required()
            self.update_adjust_tables()
        self.menus.mnAdjClearDeltaTable.enabled = True
        self.menus.mnAdjAdjust.setEnabled(True)

    def activate_survey_or_loop(self, index):
        """
        Highlights active survey or loop in tree view.
        :param index: PyQt index of newly-highlighted tree item.
        """
        item = self.obsTreeModel.itemFromIndex(index)
        # If a loop:
        try:
            if type(item) is ObsTreeLoop:
                if self.prevLoopItem is not None:
                    self.prevLoopItem.fontweight = QtGui.QFont.Normal
                    self.prevLoopItem.cellcolor = QtCore.Qt.white
                self.prevLoopItem = item
                item.cellcolor = QtCore.Qt.lightGray
                item.fontweight = QtGui.QFont.Bold
                # self.update_current_keys(item.keysurv, item.keyloop)
                self.currentLoopIndex = index
                if self.tab_widget.currentIndex() == 1:
                    self.update_drift_tables_and_plots()

            # If a survey
            elif type(item) is ObsTreeSurvey:
                if self.prevSurvItem is not None:
                    self.prevSurvItem.fontweight = QtGui.QFont.Normal
                self.prevSurvItem = item
                self.currentSurveyIndex = index
                item.fontweight = QtGui.QFont.Bold
                self.update_adjust_tables()
        except Exception as e:
            logging.exception(e, exc_info=True)

        self.obsTreeModel.layoutChanged.emit()

    def update_adjust_tables(self):
        """
        Update delta-g and datum tables after selecting a new survey in the tree view
        """
        survey = self.obsTreeModel.itemFromIndex(self.currentSurveyIndex)
        try:
            survey.delta_model.signal_adjust_update_required.connect(self.adjust_update_required)
            survey.datum_model.signal_adjust_update_required.connect(self.adjust_update_required)
            self.tab_adjust.delta_proxy_model.setSourceModel(survey.delta_model)
            self.tab_adjust.datum_proxy_model.setSourceModel(survey.datum_model)
            self.tab_adjust.results_proxy_model.setSourceModel(survey.results_model)
        except:
            pass
        self.tab_adjust.results_view.setModel(self.tab_adjust.results_proxy_model)
        self.tab_adjust.results_view.setSortingEnabled(True)

        self.tab_adjust.textAdjResults.clear()

        try:
            for line in survey.adjustment.adjustmentresults.text:
                self.tab_adjust.textAdjResults.append(line.strip())
        except:
            pass

    def update_drift_tables_and_plots(self):
        """
        Update tables based on which survey is selected in tree view
        """
        drift_method = self.obsTreeModel.itemFromIndex(self.currentLoopIndex).drift_method
        self.tab_drift.driftmethod_comboboxbox.setCurrentIndex(self.drift_lookup[drift_method])
        self.tab_drift.set_drift_method()

    def refresh_tables(self):
        """
        Connected to self.obsTreeModel.refreshView
        """
        self.tab_adjust.delta_proxy_model.beginResetModel()
        self.tab_adjust.delta_proxy_model.endResetModel()

    def on_obs_checked_change(self, selected):
        """
        Called when a checkbox state is changed, but not when a new item selected. Should update drift plots
        if on drift tab, but otherwise do nothing.
        :param selected: Selected indexes
        """
        # index = selected.indexes()
        if selected.model() is not None:
            if self.tab_widget.currentIndex() == 1:
                self.update_drift_tables_and_plots()
            elif self.tab_widget.currentIndex() == 2:
                self.adjust_update_required()
                self.tab_adjust.delta_view.update()
                self.tab_adjust.delta_view.repaint()

    def on_obs_tree_change(self, selected):
        """
        Called when the selection model changes.
        :param selected: Selected indexes
        """
        indexes = selected.indexes()
        if indexes:
            item = self.obsTreeModel.itemFromIndex(indexes[0])
            if item:
                if type(item) is ObsTreeStation:
                    self.currentStationIndex = indexes[0]
                    if self.tab_widget.currentIndex() == 0:
                        self.prep_station_plot()
                    if self.tab_widget.currentIndex() == 1:
                        self.update_drift_tables_and_plots()

    def correction_ocean_loading(self):
        show_message('Not implemented', 'Error')

    def correction_atmospheric(self):
        show_message('Not implemented', 'Error')

    def add_tare(self):
        """
        Opens a dialog to add tare to loop tare_model.
        """
        new_tare_date, new_tare_value = 0, 0
        current_loop = self.obsTreeModel.itemFromIndex(self.currentLoopIndex)
        obstreestation = current_loop.child(0)
        default_time = obstreestation.t[0]
        taredialog = AddTareDialog(default_time)
        if taredialog.exec_():
            new_tare_date = taredialog.dt_edit.dateTime()
            new_tare_value = taredialog.edit_box.text()
        tare = Tare(new_tare_date.date(), new_tare_date.time(), new_tare_value)
        current_loop.tare_model.insertRows(tare)
        self.tab_drift.process_tares(current_loop)
        self.update_drift_tables_and_plots()

    def correction_recorded_time(self):
        """
        Correct all times from an offset: when GMT time entered in relative gravimeter is bad.
        """
        # ask for time difference to apply
        text, ok = QtWidgets.QInputDialog.getText(self, 'Input parameters',
                                                  'time offset to apply (min)?')
        if ok:
            time_correction_dialog = ApplyTimeCorrection()
            time_correction_dialog.msg.exec_()
            correction_type = time_correction_dialog.time_correction_type
            t_offset = int(text)
            if correction_type == 'all':
                for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                    obstreesurvey = self.obsTreeModel.invisibleRootItem().child(i)
                    for ii in range(obstreesurvey.rowCount()):
                        obstreeloop = obstreesurvey.child(ii)
                        for iii in range(obstreeloop.rowCount()):
                            obstreestation = obstreeloop.child(iii)
                            obstreestation.t = [t + dt.timedelta(t_offset / 1440, 0, 0) for t in obstreestation.t]
                            logging.info("{} minute offset added to station {}".format(t_offset,
                                                                                       obstreestation.display_name))
            elif correction_type == 'survey':
                obstreesurvey = self.obsTreeModel.itemFromIndex(self.currentSurveyIndex)
                for ii in range(obstreesurvey.rowCount()):
                    obstreeloop = obstreesurvey.child(ii)
                    for iii in range(obstreeloop.rowCount()):
                        obstreestation = obstreeloop.child(iii)
                        obstreestation.t = [t + dt.timedelta(t_offset / 1440, 0, 0) for t in obstreestation.t]
                        logging.info(
                            "{} minute offset added to station {}".format(t_offset, obstreestation.display_name))
            elif correction_type == 'loop':
                obstreeloop = self.obsTreeModel.itemFromIndex(self.currentLoopIndex)
                for iii in range(obstreeloop.rowCount()):
                    obstreestation = obstreeloop.child(iii)
                    obstreestation.t = [t + dt.timedelta(t_offset / 1440, 0, 0) for t in obstreestation.t]
                    logging.info(
                        "{} minute offset added to station {}".format(t_offset, obstreestation.display_name))
            elif correction_type == 'station':
                indexes = self.data_treeview.selectedIndexes()
                # Because each tree item has three columns, len(indexes) equals the number of items selected * 3.
                # The next line takes every 3rd index.
                indexes = indexes[0::3]
                for index in indexes:
                    obstreestation = self.obsTreeModel.itemFromIndex(index)
                    obstreestation.t = [t + dt.timedelta(t_offset / 1440, 0, 0) for t in obstreestation.t]
                    logging.info("{} minute offset added to station {}".format(t_offset,
                                                                               obstreestation.display_name))

    def set_vertical_gradient_interval(self):
        """
        Dialog that queries user for the distance over which vertical gradient is measured.
        """
        interval = VerticalGradientDialog(self.verticalgradientinterval)
        self.vertical_gradient_interval = interval

    def vertical_gradient_write(self):
        """
        Writes a .grd file with two values: gradient and standard deviation.
        """
        deltamodel = self.tab_drift.delta_view.model()
        if deltamodel.rowCount() == 1:
            stationname = self.obsTreeModel(self.currentLoopIndex).child(0).name
            defaultfile = self.data_path + '\\\\' + stationname + '.grd'
            file_name = QtWidgets.QFileDialog.getSaveFileName(None, 'Vertical gradient file to write',
                                                         defaultfile,
                                                         selectedFilter='*.grd')
            if file_name:
                delta = deltamodel.deltas[0]
                with open(file_name, 'w') as fid:
                    fid.write('{:0.2f}'.format(-1 * delta.dg / self.verticalgradientinterval))
                    fid.write(' +/- {:0.2f}'.format(delta.sd / self.verticalgradientinterval))
        else:
            show_message("Incorrect number of delta-g's (should be 1)", "Vertical gradient error")

    def delete_selected(self):
        """
        Remove loop or survey from tree view
        """
        index = self.data_treeview.selectedIndexes()
        self.obsTreeModel.removeRow(index[0].row(), index[0].parent())
        if self.obsTreeModel.invisibleRootItem().rowCount() == 0:
            self.workspace_clear()

    def delete_station(self):
        """
        Remove station from tree view
        """
        indexes = self.data_treeview.selectedIndexes()
        # Because each tree item has three columns, len(indexes) equals the number of items selected * 3. The next
        # line takes every 3rd index.
        indexes = indexes[0::3]
        for index in reversed(indexes):
            self.obsTreeModel.removeRow(index.row(), index.parent())

    def duplicate_station(self):
        """
        Create a duplicate of a station in the tree view. Useful when the same station is observed at the end of one
        day and the start of the next day: when imported, it will appear as one station, but it should be two.
        """
        indexes = self.data_treeview.selectedIndexes()
        index = indexes[0]
        model = indexes[0].model()
        obstreeloop = model.itemFromIndex(indexes[0].parent())
        obstreesurvey = obstreeloop.parent()
        obstreestation = self.obsTreeModel.itemFromIndex(index)
        temp_obstreestation = copy.deepcopy(obstreestation)
        new_obstreestation = ObsTreeStation.from_station(temp_obstreestation)
        new_station_count = float(temp_obstreestation.station_count) + 0.1
        new_obstreestation.station_count = "{:.1f}".format(new_station_count)
        # new_tree_station = ObsTreeStation(station=new_obstreestation)
        obstreeloop.insertRow(index.row() + 1, [new_obstreestation,
                                                QtGui.QStandardItem('a'),
                                                QtGui.QStandardItem('a')])
        logging.info("Station duplicated: {}, Survey: {}, Loop: {} ".format(new_obstreestation.station_name,
                                                                            obstreesurvey.name,
                                                                            obstreeloop.name))

    def new_loop(self):
        """
        Creates a new loop in tree view
        """
        indexes = self.data_treeview.selectedIndexes()
        self.new_loop_from_indexes(indexes)

    def new_loop_from_indexes(self, indexes):
        """
        Moves stations at the specified indexes to a new loop.
        :param indexes: PyQt indexes of selected stations
        """
        if len(indexes) > 0:
            model = indexes[0].model()
            obstreeloop = model.itemFromIndex(indexes[0].parent())
            obstreesurvey = obstreeloop.parent()
            new_loop_name = str(obstreesurvey.rowCount() + 1)
            # new loop, increment from loop parent
            new_obstreeloop = ObsTreeLoop(new_loop_name)

            # iterate over indexes
            # For whatever reason we can't just appendRow the 'itemFromIndex' directly. Instead, have to make a new
            # ObsTreeItem and append that.
            logging.info('Loop {} added'.format(new_loop_name))
            first = True
            for idx in indexes:
                if idx.column() == 0:
                    obstreestation = model.itemFromIndex(idx)
                    new_obstreestation = ObsTreeStation.from_station(obstreestation)
                    logging.info('Station added to new loop: {}'.format(
                        obstreestation.name))
                    new_obstreeloop.appendRow([new_obstreestation,
                                               QtGui.QStandardItem('a'),
                                               QtGui.QStandardItem('a')])
                if first:
                    new_obstreeloop.meter = obstreestation.meter[0]
                    first = False
            for idx in reversed(indexes):
                if idx.column() == 0:
                    obstreeloop.removeRow(idx.row())
            obstreesurvey.appendRow(new_obstreeloop)

            self.obsTreeModel.layoutChanged.emit()
            self.data_treeview.expand(new_obstreeloop.index())
            self.update_drift_tables_and_plots()

    def treeview_context_menu(self, point):
        """
        Right-click context menu on tree view
        """
        self.treeviewpopMenu = QtWidgets.QMenu("Menu", self)
        self.treeviewpopMenu.addAction(self.menus.mnDeleteSurvey)
        self.treeviewpopMenu.addAction(self.menus.mnDeleteLoop)
        self.treeviewpopMenu.addAction(None)
        self.treeviewpopMenu.addAction(self.menus.mnStationDelete)
        self.treeviewpopMenu.addAction(self.menus.mnStationDuplicate)
        self.treeviewpopMenu.addAction(self.menus.mnDataNewLoop)
        # enable as appropriate
        indexes = self.data_treeview.selectedIndexes()
        if indexes:
            index = indexes[0]
            item = index.model().itemFromIndex(index)
            if type(item) is ObsTreeStation:
                self.menus.mnDeleteSurvey.setEnabled(False)
                self.menus.mnDeleteLoop.setEnabled(False)
                self.menus.mnStationDelete.setEnabled(True)
                self.menus.mnStationDuplicate.setEnabled(True)
                self.menus.mnDataNewLoop.setEnabled(True)
            elif type(item) is ObsTreeLoop or type(item) is ObsTreeSurvey:
                self.menus.mnDeleteSurvey.setEnabled(True)
                self.menus.mnDeleteLoop.setEnabled(True)
                self.menus.mnStationDelete.setEnabled(False)
                self.menus.mnStationDuplicate.setEnabled(False)
                self.menus.mnDataNewLoop.setEnabled(False)

            self.treeviewpopMenu.exec_(self.data_treeview.mapToGlobal(point))

    def status_bar_(self, status_string):
        """
        Status messages at bottom of window
        :param status_string: String to display
        """
        self.status_text = QtWidgets.QLabel(status_string)
        self.statusBar().addWidget(self.status_text, 1)

    def adjust_network(self):
        """
        Carries out network adjustment, updates output tables
        """
        if self.menus.mnAdjPyLSQ.isChecked():
            adj_type = 'PyLSQ'
        else:
            adj_type = 'Gravnet'

        self.run_inversion(adj_type)
        if self.obsTreeModel.invisibleRootItem().rowCount() > 1:
            self.menus.mnEditComputeGravityChangeAction.setEnabled(True)
        self.statusBar().showMessage("Network adjustment complete")
        self.update_adjust_tables()

    def run_inversion(self, adj_type='PyLSQ', write_out_files='n', output_root_dir='./', ):
        """
        Prepares inversion data and calls appropriate method.

        Adds an AdjustmentResults object to each Adjustment object of each Survey.
            -Counts n_deltas, n_deltas_notused, n_datums, n_datums_notused
            -Corrects datum observations for gradient
            -Runs inversion
        :param adj_type: 'PyLSQ' (numpy) or 'Gravnet'
        :param write_out_files: Write output files, 'y' or 'n'
        :param output_root_dir: Where to write output files
        """
        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        # Collect checked items into adjustment object
        if self.deltas_update_required_label.set is True:
            reply = QtWidgets.QMessageBox.question(self, 'Message',
                                                   'The Relative-gravity differences table on the Network Adjustment ' +
                                                   'is out of date. Proceed anyway?',
                                                   QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)

            if reply == QtWidgets.QMessageBox.No:
                return

        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            survey = self.obsTreeModel.invisibleRootItem().child(i)
            if survey.data(role=QtCore.Qt.CheckStateRole) == 2:
                deltas = []
                datums = []
                adjustmentresults = AdjustmentResults()

                # Form datasets for adjustment from selected table items, count number of deltas and datums (used when
                # writing metadata about adjustment).
                for ii in range(survey.delta_model.rowCount()):
                    ind = survey.delta_model.createIndex(ii, 0)
                    chk = survey.delta_model.data(ind, QtCore.Qt.CheckStateRole)
                    if chk == 2:  # Checkbox checked
                        delta = survey.delta_model.data(ind, QtCore.Qt.UserRole)
                        if delta.type == 'normal':
                            if delta.station1.data(role=QtCore.Qt.CheckStateRole) == 2 and \
                                    delta.station2.data(role=QtCore.Qt.CheckStateRole) == 2:
                                deltas.append(delta)
                                adjustmentresults.n_deltas += 1
                            else:
                                adjustmentresults.n_deltas_notused += 1
                        else:
                            deltas.append(delta)
                            adjustmentresults.n_deltas += 1
                    else:
                        adjustmentresults.n_deltas_notused += 1

                for ii in range(survey.datum_model.rowCount()):
                    ind = survey.datum_model.createIndex(ii, 0)
                    chk = survey.datum_model.data(ind, QtCore.Qt.CheckStateRole)
                    if chk == 2:  # Checkbox checked
                        # account for vertical gradient
                        datum = copy.copy(survey.datum_model.data(ind, QtCore.Qt.UserRole))
                        if hasattr(datum, 'gradient'):
                            datum.g = datum.g - datum.gradient * datum.meas_height
                        datums.append(datum)
                        adjustmentresults.n_datums += 1
                    else:
                        adjustmentresults.n_datums_notused += 1

                survey.adjustment.deltas = deltas
                survey.adjustment.datums = datums
                survey.adjustment.adjustmentresults = adjustmentresults

                try:
                    self.clear_results_model()
                    if len(survey.adjustment.datums) == 0:
                        show_message(
                            "At least one datum must be specified",
                            "Inversion error")
                        return
                    if len(survey.adjustment.deltas) == 0:
                        show_message(
                            "At least one relative-gravity difference must be specified",
                            "Inversion error")
                    if adj_type == 'PyLSQ':
                        logging.info('Numpy inversion, Survey: {}'.format(survey.name))
                        survey.numpy_inversion(output_root_dir, write_out_files)
                    elif adj_type == 'Gravnet':
                        logging.info('Gravnet inversion, Survey: {}'.format(survey.name))
                        survey.gravnet_inversion()
                    self.adjust_update_not_required()
                except Exception:
                    logging.exception("Inversion error")
                    show_message("Error during inversion. Are there standard deviations that are zero or vey small?",
                                 "Inversion error")
        QtWidgets.QApplication.restoreOverrideCursor()

    def set_adj_sd(self, survey, ao):
        """
        Update delta table based on parameters in net. adj. options
        :param survey: For which to set delta-g sd
        :param ao: AdjustmentOptions object
        """
        for i in range(survey.delta_model.rowCount()):
            ind = survey.delta_model.createIndex(i, 6)
            delta = survey.delta_model.data(ind, role=QtCore.Qt.UserRole)
            additive = 0
            factor = 1
            if ao.use_sigma_add:
                additive = ao.sigma_add
            if ao.use_sigma_factor:
                factor = ao.sigma_factor
            if ao.use_sigma_min:
                sigma = max(ao.sigma_min, delta.sd * factor + additive)
            else:
                sigma = delta.sd * factor + additive
            survey.delta_model.setData(ind, sigma, role=QtCore.Qt.EditRole)
        self.update_adjust_tables()

    def clear_delta_model(self):
        """
        Remove all deltas from delta model shown on network adjustment tab.
        """
        self.obsTreeModel.itemFromIndex(self.currentSurveyIndex).delta_model.clearDeltas()
        self.deltas_update_required()
        self.update_adjust_tables()

    def clear_datum_model(self):
        """
        Remove all datums from datum model shown on network adjustment tab.
        :return:
        """
        self.obsTreeModel.itemFromIndex(self.currentSurveyIndex).datum_model.clearDatums()
        self.update_adjust_tables()

    def clear_results_model(self):
        """
        Remove all results from results model shown on network adjustment tab.
        """
        self.obsTreeModel.itemFromIndex(self.currentSurveyIndex).results_model.clearResults()
        self.update_adjust_tables()

    def import_abs_g_simple(self):
        """
        Imports absolute data from three column file, station g stdev. Adds rows to datum_model
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None,
                                                         'Open file (3 columns, space delimited, station-g-std. dev.)',
                                                         self.data_path)
        logging.info('Importing absolute gravity data from {}'.format(fname))
        with open(fname, "r") as fh:
            line = fh.readline()
            while True:
                if not line:
                    break
                parts = line.split(" ")
                try:
                    datum = Datum(parts[0], float(parts[1]), float(parts[2]))
                except IndexError:
                    show_message('Error reading absolute gravity file. Is it three columns (station, g, std. dev.), ' +
                                 'space delimited', 'File read error')
                self.obsTreeModel.itemFromIndex(self.currentSurveyIndex).datum_model.insertRows(datum, 0)
                line = fh.readline()
                logging.info('Absolute gravity data imported, station {}'.format(parts[0]))

    def import_abs_g_complete(self):
        """
        Imports absolute gravity data as output by A10_parse.py. Adds rows to datum_model
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open A10_parse.py output file',
                                                         self.data_path)
        logging.info('Importing absolute gravity data from {}'.format(fname))
        fh = open(fname, 'r')

        # Read header line
        line = fh.readline()
        parts = line.split("\t")
        g_idx, n_idx, s_idx, d_idx, th_idx = None, None, None, None, None
        if 'Gravity' in parts:
            g_idx = parts.index('Gravity')
        if 'Station Name' in parts:
            n_idx = parts.index('Station Name')
        if 'Set Scatter' in parts:
            s_idx = parts.index('Set Scatter')
        if 'Date' in parts:
            d_idx = parts.index('Date')
        if 'Transfer Height' in parts:
            th_idx = parts.index('Transfer Height')
        if 'Gradient' in parts:
            gr_idx = parts.index('Gradient')

            while True:
                line = fh.readline()
                if not line:
                    break
                if all([g_idx, n_idx, s_idx, d_idx, th_idx]):
                    parts = line.split("\t")
                    datum = Datum(parts[n_idx], g=float(parts[g_idx]), sd=float(parts[s_idx]), date=parts[d_idx],
                                  meas_height=float(parts[th_idx]), gradient=float(parts[gr_idx]))
                    self.obsTreeModel.itemFromIndex(self.currentSurveyIndex).datum_model.insertRows(datum, 0)
                    logging.info('Absolute gravity data imported, station {}'.format(parts[n_idx]))

    def import_abs_g_direct(self):
        """
        Instantiates a PyQt dialog to select a directory with .project.txt files.
        """
        selectabsg = SelectAbsg()
        if selectabsg.exec_():
            nds = selectabsg.new_datums
        for nd in nds:
            self.obsTreeModel.itemFromIndex(self.currentSurveyIndex).datum_model.insertRows(nd, 0)

    def add_datum_manually(self):
        """
        Opens PyQt dialog to select an existing station to assign a datum value
        """
        stations = []
        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            obstreesurvey = self.obsTreeModel.invisibleRootItem().child(i)
            for ii in range(obstreesurvey.delta_model.rowCount()):
                ind = obstreesurvey.delta_model.createIndex(ii, 0)
                delta = obstreesurvey.delta_model.data(ind, QtCore.Qt.UserRole)
                stations.append(delta.sta1)
                stations.append(delta.sta2)
        stalist = list(set(stations))
        stalist.sort()
        text, ok = QtWidgets.QInputDialog.getItem(self,
                                                  'Input Dialog',
                                                  'Datum station:',
                                                  stalist)
        if ok:
            d = Datum(str(text))
            self.obsTreeModel.itemFromIndex(self.currentSurveyIndex).datum_model.insertRows(d, 0)
            logging.info('Datum station added: {}'.format(text))

    def show_adjust_options(self):
        """
        Instantiates PyQt dialog to set adjustment options
        """
        survey = self.obsTreeModel.itemFromIndex(self.currentSurveyIndex)
        adjust_options = AdjustOptions(survey.__str__(), survey.adjustment.adjustmentoptions)

        if adjust_options.exec_():
            if adjust_options.surveys_to_update == 'single':
                survey.adjustment.adjustmentoptions = adjust_options.ao
                self.set_adj_sd(survey, adjust_options.ao)
            elif adjust_options.surveys_to_update == 'all':
                for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                    survey = self.obsTreeModel.invisibleRootItem().child(i)
                    survey.adjustment.adjustmentoptions = adjust_options.ao
                    self.set_adj_sd(survey, adjust_options.ao)

    def plot_compare_datum_to_adjusted(self):
        """
        Bar plot of difference between specified datum (in datum table) and adjustment result.
        """
        survey = self.obsTreeModel.itemFromIndex(self.currentSurveyIndex)
        results = survey.results_model
        diff, lbl = [], []
        for i in range(survey.datum_model.rowCount()):
            idx = survey.datum_model.index(i, 0)
            input_datum = survey.datum_model.data(idx, role=QtCore.Qt.UserRole)
            input_name = input_datum.station
            for ii in range(results.rowCount()):
                if results.data(results.index(ii, 0), role=QtCore.Qt.DisplayRole) == input_name:
                    adj_g = results.data(results.index(ii, 1), role=QtCore.Qt.DisplayRole)
                    diff.append(float(adj_g) - (input_datum.g - input_datum.meas_height * input_datum.gradient))
                    lbl.append(input_name)
        fig, ax = plt.subplots()
        ind = np.arange(len(diff))
        ax.bar(ind, diff)
        ax.set_title('Adj. datum - input datum (microGal)')
        ax.set_xticks(ind + 0.4)
        ax.set_xticklabels(lbl)
        plt.show()

    def plot_adjust_residual_histogram(self):
        """
        Matplotlib histogram of delta-g residuals
        """
        # the histogram of the data
        survey = self.obsTreeModel.itemFromIndex(self.currentSurveyIndex)
        nrows = survey.delta_model.rowCount()
        rlist = []
        for i in range(nrows):
            idx = survey.delta_model.index(i, 7)
            results = survey.delta_model.data(idx, role=QtCore.Qt.DisplayRole)
            d = float(results.value())
            if d > -998:
                rlist.append(float(results.value()))

        plt.hist(rlist, 20, facecolor='green', alpha=0.75)
        plt.xlabel('Residual (microGal)')
        plt.ylabel('Count')
        plt.grid(True)
        plt.show()

    def plot_network_graph(self, shape='circular'):
        """
        Networkx plot of network. If shape == 'map', accurate coordinates must be present in the input file.
        :param shape: 'circular' or 'map'
        """
        g1 = nx.MultiGraph()
        g2 = nx.MultiGraph()
        stations = []
        survey = self.obsTreeModel.itemFromIndex(self.currentSurveyIndex)
        delta_model = survey.delta_model
        edge_colors = []
        if delta_model.rowCount() == 0:
            show_message('Delta table is empty. Unable to plot network graph', 'Plot error')
        else:
            for i in range(delta_model.rowCount()):
                ind = delta_model.index(i, 0)
                delta = delta_model.data(ind, role=QtCore.Qt.UserRole)
                chk = delta_model.data(ind, QtCore.Qt.CheckStateRole)
                if chk == 2:
                    edge_colors.append('k')
                    g1.add_edge(delta.sta1, delta.sta2, key=ind)
                else:
                    edge_colors.append('r')
                    g2.add_edge(delta.sta1, delta.sta2, key=ind)
                if delta.sta1 not in stations:
                    stations.append(delta.sta1)
                    g1.add_node(delta.sta1)
                    g2.add_node(delta.sta1)
                if delta.sta2 not in stations:
                    stations.append(delta.sta2)
                    g1.add_node(delta.sta2)
                    g2.add_node(delta.sta2)

            H = nx.Graph(g1)

            # edge width is proportional to number of delta-g's
            edgewidth = []
            for (u, v, d) in H.edges(data=True):
                edgewidth.append(len(g1.get_edge_data(u, v)) * 2)

            if shape == 'circular':
                pos = nx.circular_layout(H)
            elif shape == 'map':
                pos = self.station_coords

            nx.draw_networkx_edges(H, pos, width=edgewidth, alpha=0.4, node_size=0, edge_color='k')
            nx.draw_networkx_edges(g2, pos, width=1, alpha=0.4, node_size=0, edge_color='r')
            nx.draw_networkx_nodes(H, pos, node_color='w', alpha=0.4, with_labels=True)
            nx.draw_networkx_labels(H, pos)
            plt.show()

    def tide_correction_dialog(self):
        """
        Opens dialog to specify correction type
        """
        correction_type = None
        tide_correction_dialog = TideCorrectionDialog()
        if tide_correction_dialog.msg.exec_():
            correction_type = tide_correction_dialog.correction_type
        if correction_type == 'Cancel':
            return
        elif correction_type == 'Agnew':
            lat, lon, elev = [], [], []
            for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                survey = self.obsTreeModel.invisibleRootItem().child(i)
                for ii in range(survey.rowCount()):
                    loop = survey.child(ii)
                    for iii in range(loop.rowCount()):
                        station = loop.child(iii)
                        lat += station.lat
                        lon += station.long
                        elev += station.elev
            try:
                lat.remove(0.0)
            except ValueError:
                pass
            try:
                lon.remove(0.0)
            except ValueError:
                pass
            try:
                elev.remove(0.0)
            except ValueError:
                pass

            lat = np.mean(list(lat))
            lon = np.mean(list(lon))
            elev = np.mean(list(elev))

            tc = TideCoordinatesDialog(lat, lon, elev)
            if tc.exec_():
                tide_correction_agnew(self, float(tc.lat.text()),
                                      float(tc.lon.text()),
                                      float(tc.elev.text()))
            self.deltas_update_required()
            self.adjust_update_required()

    def compute_gravity_change(self, full_table=False):
        """
        Shows PyQt table of gravity change.

        :param full_table: if True, entire tabular output file for data release is shown. Includes station
        coordinates, g, standard deviation, and gravity change.
        """
        compare_station, initial_station, iteration_station, iteration_name = None, None, None, None
        logging.info('Calculating gravity change')
        first = True
        unique_station_names = set()
        unique_stations = list()
        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            survey = self.obsTreeModel.invisibleRootItem().child(i)
            for ii in range(survey.rowCount()):
                loop = survey.child(ii)
                for iii in range(loop.rowCount()):
                    station = loop.child(iii)
                    unique_station_names.add(station.station_name)
                    unique_stations.append(station)
        unique_station_names = sorted(unique_station_names)
        unique_stations = sorted(unique_stations, key=lambda x: x.station_name)
        out_table_iteration, out_table_cumulative = [], []
        header1, header2 = [], []
        lat, lon, elev, all_g = [], [], [], []
        if full_table:
            for station in unique_stations:
                station_g = []
                g_header = []
                lat.append(station.lat[0])
                lon.append(station.long[0])
                elev.append(station.elev[0])
                for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                    survey = self.obsTreeModel.invisibleRootItem().child(i)
                    station_found = False
                    g_header.append(survey.name)
                    g_header.append(survey.name + '_sd')
                    for i in range(survey.results_model.rowCount()):
                        adj_station = survey.results_model.data(survey.results_model.index(i, 0),
                                                                role=QtCore.Qt.UserRole)
                        if adj_station.station == station.station_name[:6]:
                            station_found = True
                            break
                    if station_found:
                        station_g.append('{:0.1f}'.format(adj_station.g))
                        station_g.append('{:0.1f}'.format(adj_station.sd))
                    else:
                        station_g.append('-999')
                        station_g.append('-999')
                all_g.append(station_g)

        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            survey = self.obsTreeModel.invisibleRootItem().child(i)
            diff_cumulative = []
            diff_iteration = []
            if full_table:
                diff_cumulative_sd, diff_iteration_sd = [], []
            if first:
                # Calculate both the between-survey change and the change from the initial survey
                initial_survey = survey.results_model
                iteration_reference = initial_survey
                reference_name = survey.name
                iteration_name = reference_name
                first = False
            else:
                if not full_table:
                    header1.append(str(iteration_name) + '_to_' + str(survey.name))
                    header2.append(str(reference_name) + '_to_' + str(survey.name))
                else:
                    header1.append('dH2O_' + str(iteration_name) + '_to_' + str(survey.name))
                    header1.append('dH2O_sd_' + str(iteration_name) + '_to_' + str(survey.name))
                    header2.append('dH2O_' + str(reference_name) + '_to_' + str(survey.name))
                    header2.append('dH2O_sd_' + str(reference_name) + '_to_' + str(survey.name))

                compare_survey = survey.results_model
                for station_name in unique_station_names:

                    for ii in range(initial_survey.rowCount()):
                        initial_station = initial_survey.data(initial_survey.index(ii, 0),
                                                              role=QtCore.Qt.UserRole)
                        # Iterate through, look for matching station
                        if initial_station.station == station_name[:6]:
                            break
                        else:
                            initial_station = None
                    for ii in range(iteration_reference.rowCount()):
                        iteration_station = iteration_reference.data(iteration_reference.index(ii, 0),
                                                                     role=QtCore.Qt.UserRole)
                        # Iterate through, look for matching station
                        if iteration_station.station == station_name[:6]:
                            break
                        else:
                            iteration_station = None
                    for ii in range(compare_survey.rowCount()):
                        compare_station = compare_survey.data(compare_survey.index(ii, 0),
                                                              role=QtCore.Qt.UserRole)
                        if compare_station.station == station_name[:6]:
                            break
                        else:
                            compare_station = None
                    if initial_station is not None and compare_station is not None:
                        if not full_table:
                            diff_cumulative.append("{:0.1f}".format(compare_station.g - initial_station.g))
                        else:
                            diff_cumulative.append("{:0.2f}".format((compare_station.g - initial_station.g) / 41.9))
                            var = np.sqrt(compare_station.sd ** 2 + initial_station.sd ** 2) / 41.9
                            if np.isnan(var):
                                diff_cumulative_sd.append('-999')
                            else:
                                diff_cumulative_sd.append("{:0.2f}".format(var))
                    else:
                        diff_cumulative.append("-999")
                        if full_table:
                            diff_cumulative_sd.append("-999")  # for sd column
                    if iteration_station is not None and compare_station is not None:
                        if not full_table:
                            diff_iteration.append("{:0.1f}".format(compare_station.g - iteration_station.g))
                        else:
                            diff_iteration.append("{:0.2f}".format((compare_station.g - iteration_station.g) / 41.9))
                            var = np.sqrt(compare_station.sd ** 2 + iteration_station.sd ** 2) / 41.9
                            if np.isnan(var):
                                diff_iteration_sd.append('-999')
                            else:
                                diff_iteration_sd.append("{:0.2f}".format(var))
                    else:
                        diff_iteration.append("-999")
                        if full_table:
                            diff_iteration_sd.append("-999")  # for sd column
                out_table_iteration.append(diff_iteration)
                out_table_cumulative.append(diff_cumulative)
                if full_table:
                    out_table_iteration.append(diff_iteration_sd)
                    out_table_cumulative.append(diff_cumulative_sd)
                iteration_reference = compare_survey
                iteration_name = survey.name
        out_table = [list(unique_station_names)] + out_table_iteration + out_table_cumulative

        if not full_table:
            header = ['station'] + header1 + header2
            table = out_table
            GravityChangeTable(self, table, header)
        else:
            header = ['Station', 'Latitude', 'Longitude', 'Elevation'] + g_header + header1 + header2
            # transpose table
            g = [list(i) for i in zip(*all_g)]
            table = [unique_station_names, lat, lon, elev]
            table += g
            table += out_table_iteration
            table += out_table_cumulative
            # transpose back
            table = [list(i) for i in zip(*table)]
            table = [header] + table
            return table

    def write_tabular_data(self):
        """
        Export gravity change table to csv file
        """
        fn = 'GSadjust_TabularData' + time.strftime("%Y%m%d-%H%M") + '.csv'
        table = self.compute_gravity_change(full_table=True)

        with open(fn, 'w') as g:
            wr = csv.writer(g)
            for row in table:
                wr.writerow(row)

    def write_metadata_text(self):
        """
        Write metadata text to file. Useful for USGS data releases.
        """
        fn = 'GSadjust_MetadataText' + time.strftime("%Y%m%d-%H%M") + '.txt'
        results_written, first = False, False
        fmt = '%Y-%m-%d'
        with open(fn, 'w') as fid:
            for i in range(self.obsTreeModel.rowCount()):
                survey = self.obsTreeModel.invisibleRootItem().child(i)
                datetemp = dt.datetime.utcfromtimestamp((int(survkey) - 719162) * 86400.)
                datestr = datetemp.strftime(fmt)
                if survey.adjustment.adjustmentresults.text:  # check that there are results
                    if first:
                        fid.write('Attribute accuracy is evaluated from the least-squares network adjustment results. ')
                        first = False
                    results_written = True
                    fid.write('For the {} survey, the minimum and maximum gravity-difference residuals were {:0.1f} '
                              'and {:0.1f} '.format(datestr,
                                                    survey.adjustment.adjustmentresults.min_dg_residual,
                                                    survey.adjustment.adjustmentresults.max_dg_residual))
                    fid.write(
                        'microGal, respectively. The minimum and maximum datum (absolute-gravity station) residuals ')
                    fid.write(
                        'were {:0.1f} and {:0.1f} microGal, respectively. '.format(
                            survey.adjustment.adjustmentresults.min_datum_residual,
                            survey.adjustment.adjustmentresults.max_datum_residual))
                    fid.write('The average standard deviation of the adjusted gravity values at each station')
                    fid.write(
                        ' (derived from the network adjustment) was {:0.1f} microGal. '.format(
                            survey.adjustment.adjustmentresults.avg_stdev))
                    # TODO: account for instance of 1 outlier ('1 was removed')
                    fid.write('{} out of {} possible gravity differences were used in the adjustment ({} were removed '
                              .format(survey.adjustment.adjustmentresults.n_deltas -
                                      survey.adjustment.adjustmentresults.n_deltas_notused,
                                      survey.adjustment.adjustmentresults.n_deltas,
                                      survey.adjustment.adjustmentresults.n_deltas_notused))
                    fid.write('as outliers). {} out of {} possible datum observations were used. '.format(
                        survey.adjustment.adjustmentresults.n_datums -
                        survey.adjustment.adjustmentresults.n_datums_notused,
                        survey.adjustment.adjustmentresults.n_datums))
        if not results_written:
            show_message('No network adjustment results', 'Write error')

    ###########################################################################
    # Menus
    ###########################################################################
    def close_windows(self):
        """
        Function for closing all windows
        """
        self.close()

    @staticmethod
    def show_help():
        """
        Shows compiled help file created using Dr. Explain
        """
        webbrowser.open('file://' + os.path.realpath('../dist/help/index.htm'))


class BoldDelegate(QtWidgets.QStyledItemDelegate):
    """
    Makes selected item in tree view bold.
    See     http://www.qtcentre.org/threads/61716-Set-the-color-of-a-row-in-a-qtreeview
    """
    def paint(self, painter, option, index):
        m = index.model().itemFromIndex(index)
        # decide here if item should be bold and set font weight to bold if needed
        if not hasattr(m, 'fontweight'):
            option.font.setWeight(QtGui.QFont.Normal)
            m.cellcolor = QtCore.Qt.white
        else:
            option.font.setWeight(m.fontweight)
        painter.fillRect(option.rect, m.cellcolor)
        QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)


def handle_exception(exc_type, exc_value, exc_traceback):
    """ 
    Sends exceptions to log file
    """
    # KeyboardInterrupt is a special case, don't raise the error dialog when it occurs.
    if issubclass(exc_type, KeyboardInterrupt):
        if QtWidgets.qApp:
            QtWidgets.qApp.quit()
        return

    filename, line, dummy, dummy = traceback.extract_tb(exc_traceback).pop()
    filename = os.path.basename(filename)
    error = "{}: {}".format(exc_type.__name__, exc_value)
    logging.error(error + " at line {:d} of file {}".format(line, filename))


def main():
    # start log file
    fn = 'GSadjustLog_' + time.strftime("%Y%m%d-%H%M") + '.txt'
    logging.basicConfig(filename=fn, format='%(levelname)s:%(message)s', level=logging.DEBUG)
    sys.excepthook = handle_exception
    app = QtWidgets.QApplication(sys.argv)
    app.setWindowIcon(QtGui.QIcon('g.png'))
    ex = MainProg()
    app.exec_()


# Import here to avoid circular import error
from gui_objects import show_message, date_method_dialog, SelectAbsg, AdjustOptions

if __name__ == '__main__':
    main()
